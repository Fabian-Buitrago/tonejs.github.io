// Generated by dts-bundle v0.7.3

declare module 'tone' {
    export { getContext, setContext } from "tone/core/Global";
    export * from "tone/classes";
    export { start } from "tone/core/Global";
    /**
        * The current audio context time
        * @Category Core
        */
    export function now(): import("./core/type/Units").Seconds;
    /**
        * The Transport object belonging to the global Tone.js Context
        * @Category Core
        */
    export const Transport: import("./classes").Transport;
    /**
        * The Destination (output) belonging to the global Tone.js Context
        * @Category Core
        */
    export const Destination: import("./classes").Destination;
}

declare module 'tone/core/Global' {
    import { Context } from "tone/core/context/Context";
    /**
        * Returns the default system-wide [[Context]]
        * @category Core
        */
    export function getContext(): Context;
    /**
        * Set the default audio context
        * @category Core
        */
    export function setContext(context: Context | AudioContext | OfflineAudioContext): void;
    /**
        * Most browsers will not play _any_ audio until a user
        * clicks something (like a play button). Invoke this method
        * on a click or keypress event handler to start the audio context.
        * More about the Autoplay policy
        * [here](https://developers.google.com/web/updates/2017/09/autoplay-policy-changes#webaudio)
        * @example
        * document.querySelector('#playbutton').addEventListener('click', async () => {
        * 	await Tone.start()
        * 	console.log('audio ready')
        * })
        * @category Core
        */
    export function start(): Promise<void>;
}

declare module 'tone/classes' {
    export * from "tone/core/index";
    export * from "tone/source/index";
    export * from "tone/signal/index";
    export * from "tone/instrument/index";
    export * from "tone/event/index";
    export * from "tone/effect/index";
    export * from "tone/component/index";
}

declare module 'tone/core/context/Context' {
    import { TickerClockSource } from "tone/core/clock/Ticker";
    import { Seconds } from "tone/core/type/Units";
    import { Emitter } from "tone/core/util/Emitter";
    import { Omit } from "tone/core/util/Interface";
    import { AnyAudioContext } from "tone/core/context/AudioContext";
    type Transport = import("../clock/Transport").Transport;
    type Destination = import("./Destination").Destination;
    export type ContextLatencyHint = AudioContextLatencyCategory | "fastest";
    export type ExcludedFromBaseAudioContext = "onstatechange" | "addEventListener" | "removeEventListener" | "listener" | "dispatchEvent" | "audioWorklet" | "destination" | "createScriptProcessor";
    export type BaseAudioContextSubset = Omit<BaseAudioContext, ExcludedFromBaseAudioContext>;
    export interface ContextOptions {
            clockSource: TickerClockSource;
            latencyHint: ContextLatencyHint;
            lookAhead: Seconds;
            updateInterval: Seconds;
            context: AnyAudioContext;
    }
    export interface ContextTimeoutEvent {
            callback: (...args: any[]) => void;
            id: number;
            time: Seconds;
    }
    /**
        * Wrapper around the native AudioContext.
        * @category Core
        */
    export class Context extends Emitter<"statechange" | "tick"> implements BaseAudioContextSubset {
            readonly name: string;
            /**
                * The amount of time into the future events are scheduled. Giving Web Audio
                * a short amount of time into the future to schedule events can reduce clicks and
                * improve performance. This value can be set to 0 to get the lowest latency.
                */
            lookAhead: Seconds;
            /**
                * private reference to the BaseAudioContext
                */
            protected readonly _context: AnyAudioContext;
            /**
                * Indicates if the context is an OfflineAudioContext or an AudioContext
                */
            readonly isOffline: boolean;
            constructor(context?: AnyAudioContext);
            constructor(options?: Partial<ContextOptions>);
            static getDefaults(): ContextOptions;
            createAnalyser(): AnalyserNode;
            createOscillator(): OscillatorNode;
            createBufferSource(): AudioBufferSourceNode;
            createBiquadFilter(): BiquadFilterNode;
            createBuffer(numberOfChannels: number, length: number, sampleRate: number): AudioBuffer;
            createChannelMerger(numberOfInputs?: number | undefined): ChannelMergerNode;
            createChannelSplitter(numberOfOutputs?: number | undefined): ChannelSplitterNode;
            createConstantSource(): ConstantSourceNode;
            createConvolver(): ConvolverNode;
            createDelay(maxDelayTime?: number | undefined): DelayNode;
            createDynamicsCompressor(): DynamicsCompressorNode;
            createGain(): GainNode;
            createIIRFilter(feedForward: number[] | Float32Array, feedback: number[] | Float32Array): IIRFilterNode;
            createPanner(): PannerNode;
            createPeriodicWave(real: number[] | Float32Array, imag: number[] | Float32Array, constraints?: PeriodicWaveConstraints | undefined): PeriodicWave;
            createStereoPanner(): StereoPannerNode;
            createWaveShaper(): WaveShaperNode;
            createMediaStreamSource(stream: MediaStream): MediaStreamAudioSourceNode;
            decodeAudioData(audioData: ArrayBuffer): Promise<AudioBuffer>;
            /**
                * The current time in seconds of the AudioContext.
                */
            readonly currentTime: Seconds;
            /**
                * The current time in seconds of the AudioContext.
                */
            readonly state: AudioContextState;
            /**
                * The current time in seconds of the AudioContext.
                */
            readonly sampleRate: number;
            /**
                * The listener
                */
            readonly listener: AudioListener;
            /**
                * There is only one Transport per Context. It is created on initialization.
                */
            transport: Transport;
            /**
                * A reference to the Context's destination node.
                */
            destination: Destination;
            /**
                * Create an audio worklet node from a name and options. The module
                * must first be loaded using [[addAudioWorkletModule]].
                */
            createAudioWorkletNode(name: string, options?: Partial<AudioWorkletNodeOptions>): AudioWorkletNode;
            /**
                * Add an AudioWorkletProcessor module
                * @param url The url of the module
                * @param name The name of the module
                */
            addAudioWorkletModule(url: string, name: string): Promise<void>;
            /**
                * Returns a promise which resolves when all of the worklets have been loaded on this context
                */
            protected workletsAreReady(): Promise<void>;
            /**
                * How often the interval callback is invoked.
                * This number corresponds to how responsive the scheduling
                * can be. context.updateInterval + context.lookAhead gives you the
                * total latency between scheduling an event and hearing it.
                */
            updateInterval: Seconds;
            /**
                * What the source of the clock is, either "worker" (default),
                * "timeout", or "offline" (none).
                */
            clockSource: TickerClockSource;
            /**
                * The type of playback, which affects tradeoffs between audio
                * output latency and responsiveness.
                * In addition to setting the value in seconds, the latencyHint also
                * accepts the strings "interactive" (prioritizes low latency),
                * "playback" (prioritizes sustained playback), "balanced" (balances
                * latency and performance), and "fastest" (lowest latency, might glitch more often).
                * @example
                * //set the lookAhead to 0.3 seconds
                * Tone.context.latencyHint = 0.3;
                */
            latencyHint: ContextLatencyHint | Seconds;
            /**
                * The unwrapped AudioContext.
                */
            readonly rawContext: AnyAudioContext;
            /**
                * The current audio context time plus a short {@link lookAhead}.
                */
            now(): Seconds;
            /**
                * Starts the audio context from a suspended state. This is required
                * to initially start the AudioContext.
                */
            resume(): Promise<void>;
            /**
                * Promise which is invoked when the context is running.
                * Tries to resume the context if it's not started.
                */
            close(): Promise<void>;
            /**
                * Generate a looped buffer at some constant value.
                */
            getConstant(val: number): AudioBufferSourceNode;
            /**
                * Clean up. Also closes the audio context.
                */
            dispose(): this;
            /**
                * A setTimeout which is guaranteed by the clock source.
                * Also runs in the offline context.
                * @param  fn       The callback to invoke
                * @param  timeout  The timeout in seconds
                * @returns ID to use when invoking Context.clearTimeout
                */
            setTimeout(fn: (...args: any[]) => void, timeout: Seconds): number;
            /**
                * Clears a previously scheduled timeout with Tone.context.setTimeout
                * @param  id  The ID returned from setTimeout
                */
            clearTimeout(id: number): this;
            /**
                * Clear the function scheduled by [[setInterval]]
                */
            clearInterval(id: number): this;
            /**
                * Adds a repeating event to the context's callback clock
                */
            setInterval(fn: (...args: any[]) => void, interval: Seconds): number;
    }
    export {};
}

declare module 'tone/core/index' {
    export { ToneAudioNode } from "tone/core/context/ToneAudioNode";
    export { Param } from "tone/core/context/Param";
    export { Gain } from "tone/core/context/Gain";
    export { Context } from "tone/core/context/Context";
    export { OfflineContext } from "tone/core/context/OfflineContext";
    export { Offline } from "tone/core/context/Offline";
    export { ToneAudioBuffer } from "tone/core/context/ToneAudioBuffer";
    export { ToneAudioBuffers } from "tone/core/context/ToneAudioBuffers";
    export { Delay } from "tone/core/context/Delay";
    export { Clock } from "tone/core/clock/Clock";
    export { Frequency } from "tone/core/type/Frequency";
    export { Time } from "tone/core/type/Time";
    export { Ticks } from "tone/core/type/Ticks";
    export { Midi } from "tone/core/type/Midi";
    export { TransportTime } from "tone/core/type/TransportTime";
    export { Draw } from "tone/core/util/Draw";
    export { StateTimeline } from "tone/core/util/StateTimeline";
    export { IntervalTimeline } from "tone/core/util/IntervalTimeline";
    export { Timeline } from "tone/core/util/Timeline";
    export { Emitter } from "tone/core/util/Emitter";
    export { Tone } from "tone/core/Tone";
    export { Destination } from "tone/core/context/Destination";
    export { Transport } from "tone/core/clock/Transport";
    export { dbToGain, gainToDb, intervalToFrequencyRatio } from "tone/core/type/Conversions";
    export { optionsFromArguments, defaultArg } from "tone/core/util/Defaults";
    export * from "tone/core/Connect";
    export * from "tone/core/util/TypeCheck";
    import * as Unit from "tone/core/type/Units";
    export { Unit };
    import * as debug from "tone/core/util/Debug";
    export { debug };
}

declare module 'tone/source/index' {
    export * from "tone/source/Noise";
    export * from "tone/source/UserMedia";
    export * from "tone/source/oscillator/Oscillator";
    export * from "tone/source/oscillator/AMOscillator";
    export * from "tone/source/oscillator/FMOscillator";
    export * from "tone/source/oscillator/PulseOscillator";
    export * from "tone/source/oscillator/FatOscillator";
    export * from "tone/source/oscillator/PWMOscillator";
    export * from "tone/source/oscillator/OmniOscillator";
    export * from "tone/source/oscillator/ToneOscillatorNode";
    export * from "tone/source/oscillator/LFO";
    export * from "tone/source/buffer/ToneBufferSource";
    export * from "tone/source/buffer/Player";
    export * from "tone/source/buffer/Players";
    export * from "tone/source/buffer/GrainPlayer";
}

declare module 'tone/signal/index' {
    export * from "tone/signal/Add";
    export * from "tone/signal/Abs";
    export * from "tone/signal/AudioToGain";
    export * from "tone/signal/GainToAudio";
    export * from "tone/signal/Multiply";
    export * from "tone/signal/Negate";
    export * from "tone/signal/Signal";
    export * from "tone/signal/Subtract";
    export * from "tone/signal/WaveShaper";
    export * from "tone/signal/Zero";
}

declare module 'tone/instrument/index' {
    export * from "tone/instrument/Synth";
    export * from "tone/instrument/Sampler";
    export * from "tone/instrument/PolySynth";
    export * from "tone/instrument/MembraneSynth";
    export * from "tone/instrument/MetalSynth";
    export * from "tone/instrument/PluckSynth";
    export * from "tone/instrument/FMSynth";
    export * from "tone/instrument/NoiseSynth";
}

declare module 'tone/event/index' {
    export { Part } from "tone/event/Part";
    export { Sequence } from "tone/event/Sequence";
    export { ToneEvent } from "tone/event/ToneEvent";
    export { Loop } from "tone/event/Loop";
}

declare module 'tone/effect/index' {
    export { FeedbackDelay } from "tone/effect/FeedbackDelay";
    export { Reverb } from "tone/effect/Reverb";
    export { Distortion } from "tone/effect/Distortion";
}

declare module 'tone/component/index' {
    export * from "tone/component/analysis/Analyser";
    export * from "tone/component/analysis/Meter";
    export * from "tone/component/analysis/FFT";
    export * from "tone/component/analysis/DCMeter";
    export * from "tone/component/analysis/Waveform";
    export * from "tone/component/analysis/Follower";
    export * from "tone/component/channel/CrossFade";
    export * from "tone/component/channel/Merge";
    export * from "tone/component/channel/MultibandSplit";
    export * from "tone/component/channel/Panner";
    export * from "tone/component/channel/PanVol";
    export * from "tone/component/channel/Volume";
    export * from "tone/component/channel/Solo";
    export * from "tone/component/channel/Split";
    export * from "tone/component/dynamics/Compressor";
    export * from "tone/component/envelope/AmplitudeEnvelope";
    export * from "tone/component/envelope/Envelope";
    export * from "tone/component/filter/EQ3";
    export * from "tone/component/filter/Filter";
    export * from "tone/component/filter/OnePoleFilter";
    export * from "tone/component/filter/FeedbackCombFilter";
    export * from "tone/component/filter/LowpassCombFilter";
    export * from "tone/component/filter/Convolver";
}

declare module 'tone/core/clock/Ticker' {
    import { Seconds } from "tone/core/type/Units";
    export type TickerClockSource = "worker" | "timeout" | "offline";
    /**
        * A class which provides a reliable callback using either
        * a Web Worker, or if that isn't supported, falls back to setTimeout.
        */
    export class Ticker {
            constructor(callback: () => void, type: TickerClockSource, updateInterval: Seconds);
            /**
                * The rate in seconds the ticker will update
                */
            updateInterval: Seconds;
            /**
                * The type of the ticker, either a worker or a timeout
                */
            type: TickerClockSource;
            /**
                * Clean up
                */
            dispose(): void;
    }
}

declare module 'tone/core/type/Units' {
    export * from "tone/core/type/NoteUnits";
    import { Note } from "tone/core/type/NoteUnits";
    /**
        * A number representing a time in seconds
        * @category Unit
        */
    export type Seconds = number;
    /**
        * A number used to measure the intensity of a sound on a logarithmic scale.
        * @category Unit
        */
    export type Decibels = number;
    /**
        * A number that is between [0, 1]
        * @category Unit
        */
    export type NormalRange = number;
    /**
        * A number that is between [-1, 1]
        * @category Unit
        */
    export type AudioRange = number;
    /**
        * Half-step note increments, i.e. 12 is an octave above the root. and 1 is a half-step up.
        * @category Unit
        */
    export type Interval = number;
    /**
        * A number representing the multiplication factor applied to a signal
        * @category Unit
        */
    export type GainFactor = number;
    /**
        * A number greater than or equal to 0.
        * @category Unit
        */
    export type Positive = number;
    /**
        * Represents a subdivision of a measure.
        * The number represents the subdivision. "t" represents a triplet.
        * e.g. "4n" is a quarter note, and "4t" is a quarter note triplet.
        * @category Unit
        */
    export type Subdivision = "1m" | "1n" | "2n" | "2t" | "4n" | "4t" | "8n" | "8t" | "16n" | "16t" | "32n" | "32t" | "64n" | "64t" | "128n" | "128t" | "256n" | "256t" | "0";
    /**
        * A time object has a subdivision as the keys and a number as the values.
        * @example
        * const time = {
        * 	"2n" : 1,
        * 	"8n" : 3
        * } // = 2n + 8n * 3
        * @example
        * const time = {
        * 	"1m" : 1,
        * 	"8n" : -1
        * } // = 1m - 8n
        * @category Unit
        */
    export type TimeObject = {
            [sub in Subdivision]?: number;
    };
    /**
        * Time can be described in a number of ways. Read more [Time](https://github.com/Tonejs/Tone.js/wiki/Time).
        * * Numbers, which will be taken literally as the time (in seconds).
        * * Notation, ("4n", "8t") describes time in BPM and time signature relative values.
        * * TransportTime, ("4:3:2") will also provide tempo and time signature relative times in the form BARS:QUARTERS:SIXTEENTHS.
        * * Frequency, ("8hz") is converted to the length of the cycle in seconds.
        * * Now-Relative, ("+1") prefix any of the above with "+" and it will be interpreted as "the current time plus whatever expression follows".
        * * Object, ({"4n" : 3, "8t" : -1}). The resulting time is equal to the sum of all of the keys multiplied by the values in the object.
        * * No Argument, for methods which accept time, no argument will be interpreted as "now" (i.e. the currentTime).
        * @category Unit
        */
    export type Time = string | Seconds | TimeObject | Subdivision;
    /**
        * Frequency can be described similar to time, except ultimately the
        * values are converted to frequency instead of seconds. A number
        * is taken literally as the value in hertz. Additionally any of the
        * Time encodings can be used. Note names in the form
        * of NOTE OCTAVE (i.e. C4) are also accepted and converted to their
        * frequency value.
        * @category Unit
        */
    export type Frequency = Subdivision | Note | string | Hertz;
    /**
        *
        * @category Unit
        */
    export type TimeSignature = number | number[];
    /**
        * TransportTime describes a position along the Transport's timeline. It is
        * similar to Time in that it uses all the same encodings, but TransportTime specifically
        * pertains to the Transport's timeline, which is startable, stoppable, loopable, and seekable.
        * [Read more](https://github.com/Tonejs/Tone.js/wiki/TransportTime)
        * @category Unit
        */
    export type TransportTime = Time;
    /**
        * Ticks are the basic subunit of the Transport. They are
        * the smallest unit of time that the Transport supports.
        * @category Unit
        */
    export type Ticks = number;
    /**
        * Beats per minute
        * @category Unit
        */
    export type BPM = number;
    /**
        * Angle between 0 and 360.
        * @category Unit
        */
    export type Degrees = number;
    /**
        * Angle between 0 and 2 * PI.
        * @category Unit
        */
    export type Radians = number;
    /**
        * A colon-separated representation of time in the form of
        * Bars:Beats:Sixteenths.
        * @category Unit
        */
    export type BarsBeatsSixteenths = string;
    /**
        * Sampling is the reduction of a continuous signal to a discrete signal.
        * Audio is typically sampled 44100 times per second.
        * @category Unit
        */
    export type Samples = number | "samples";
    /**
        * Hertz are a frequency representation defined as one cycle per second.
        * @category Unit
        */
    export type Hertz = number;
    /**
        * A Cent is 1/100th of a semitone.
        * e.g. a value of 50 cents would be halfway between two intervals.
        * @category Unit
        */
    export type Cents = number;
    /**
        * One millisecond is a thousandth of a second.
        * @category Unit
        */
    export type Milliseconds = number;
    /**
        * A value which is a power of 2
        * @category Unit
        */
    export type PowerOfTwo = number;
    /**
        * Map the unit name to a unit value
        */
    interface UnitMap {
            number: number;
            decibels: Decibels;
            normalRange: NormalRange;
            audioRange: AudioRange;
            gain: GainFactor;
            positive: Positive;
            time: Time;
            frequency: Frequency;
            transportTime: TransportTime;
            ticks: Ticks;
            bpm: BPM;
            degrees: Degrees;
            radians: Radians;
            samples: Samples;
            hertz: Hertz;
            cents: Cents;
    }
    /**
        * All of the unit types
        * @category Unit
        */
    export type Unit = UnitMap[keyof UnitMap];
    /**
        * All of the unit names
        * @category Unit
        */
    export type UnitName = keyof UnitMap;
}

declare module 'tone/core/util/Emitter' {
    import { Tone } from "tone/core/Tone";
    export interface EmitterEventObject {
            [event: string]: Array<(...args: any[]) => void>;
    }
    /**
        * Emitter gives classes which extend it
        * the ability to listen for and emit events.
        * Inspiration and reference from Jerome Etienne's [MicroEvent](https://github.com/jeromeetienne/microevent.js).
        * MIT (c) 2011 Jerome Etienne.
        */
    export class Emitter<EventType extends string = string> extends Tone {
            readonly name: string;
            /**
                * Bind a callback to a specific event.
                * @param  event     The name of the event to listen for.
                * @param  callback  The callback to invoke when the event is emitted
                */
            on(event: EventType, callback: (...args: any[]) => void): this;
            /**
                * Bind a callback which is only invoked once
                * @param  event     The name of the event to listen for.
                * @param  callback  The callback to invoke when the event is emitted
                */
            once(event: EventType, callback: (...args: any[]) => void): this;
            /**
                * Remove the event listener.
                * @param  event     The event to stop listening to.
                * @param  callback  The callback which was bound to the event with Emitter.on.
                *                   If no callback is given, all callbacks events are removed.
                */
            off(event: EventType, callback?: (...args: any[]) => void): this;
            /**
                * Invoke all of the callbacks bound to the event
                * with any arguments passed in.
                * @param  event  The name of the event.
                * @param args The arguments to pass to the functions listening.
                */
            emit(event: any, ...args: any[]): this;
            /**
                * Add Emitter functions (on/off/emit) to the object
                */
            static mixin(constr: any): void;
            /**
                * Clean up
                */
            dispose(): this;
    }
}

declare module 'tone/core/util/Interface' {
    export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
    /**
        * Make the property not writable using `defineProperty`. Internal use only.
        */
    export function readOnly(target: object, property: string | string[]): void;
    /**
        * Make an attribute writeable. Internal use only.
        */
    export function writable(target: object, property: string | string[]): void;
    export const noOp: (...args: any[]) => any;
    /**
        * Recursive Partial taken from here: https://stackoverflow.com/a/51365037
        */
    export type RecursivePartial<T> = {
            [P in keyof T]?: T[P] extends Array<infer U> ? Array<RecursivePartial<U>> : T[P] extends object ? RecursivePartial<T[P]> : T[P];
    };
}

declare module 'tone/core/context/AudioContext' {
    /**
        * Create a new AudioContext
        */
    export function createAudioContext(): AudioContext;
    /**
        * Create a new OfflineAudioContext
        */
    export function createOfflineAudioContext(channels: number, length: number, sampleRate: number): OfflineAudioContext;
    /**
        * Either the online or offline audio context
        */
    export type AnyAudioContext = AudioContext | OfflineAudioContext;
    /**
        * Interface for things that Tone.js adds to the window
        */
    interface ToneWindow extends Window {
            TONE_SILENCE_LOGGING?: boolean;
            TONE_DEBUG_CLASS?: string;
    }
    /**
        * A reference to the window object
        * @hidden
        */
    export const theWindow: ToneWindow | null;
    /**
        * If the browser has a window object which has an AudioContext
        * @hidden
        */
    export const hasAudioContext: boolean | null;
    export function createAudioWorkletNode(context: AnyAudioContext, name: string, options?: Partial<AudioWorkletNodeOptions>): AudioWorkletNode;
    export {};
}

declare module 'tone/core/context/ToneAudioNode' {
    import { Param } from "tone/core/context/Param";
    import { ToneWithContext, ToneWithContextOptions } from "tone/core/context/ToneWithContext";
    export type InputNode = ToneAudioNode | AudioNode | Param<any> | AudioParam;
    export type OutputNode = ToneAudioNode | AudioNode;
    /**
        * The possible options for this node
        */
    export type ToneAudioNodeOptions = ToneWithContextOptions;
    /**
        * ToneAudioNode is the base class for classes which process audio.
        */
    export abstract class ToneAudioNode<Options extends ToneAudioNodeOptions = ToneAudioNodeOptions> extends ToneWithContext<Options> {
            /**
                * The name of the class
                */
            abstract readonly name: string;
            /**
                * The input node or nodes. If the object is a source,
                * it does not have any input and this.input is undefined.
                */
            abstract input: InputNode | undefined;
            /**
                * The output nodes. If the object is a sink,
                * it does not have any output and this.output is undefined.
                */
            abstract output: OutputNode | undefined;
            /**
                * The number of inputs feeding into the AudioNode.
                * For source nodes, this will be 0.
                */
            readonly numberOfInputs: number;
            /**
                * The number of outputs of the AudioNode.
                */
            readonly numberOfOutputs: number;
            /**
                * List all of the node that must be set to match the ChannelProperties
                */
            protected _internalChannels: OutputNode[];
            /**
                * channelCount is the number of channels used when up-mixing and down-mixing
                * connections to any inputs to the node. The default value is 2 except for
                * specific nodes where its value is specially determined.
                */
            channelCount: number;
            /**
                * channelCountMode determines how channels will be counted when up-mixing and
                * down-mixing connections to any inputs to the node.
                * The default value is "max". This attribute has no effect for nodes with no inputs.
                * * "max" - computedNumberOfChannels is the maximum of the number of channels of all connections to an input. In this mode channelCount is ignored.
                * * "clamped-max" - computedNumberOfChannels is determined as for "max" and then clamped to a maximum value of the given channelCount.
                * * "explicit" - computedNumberOfChannels is the exact value as specified by the channelCount.
                */
            channelCountMode: ChannelCountMode;
            /**
                * channelInterpretation determines how individual channels will be treated
                * when up-mixing and down-mixing connections to any inputs to the node.
                * The default value is "speakers".
                */
            channelInterpretation: ChannelInterpretation;
            /**
                * connect the output of a ToneAudioNode to an AudioParam, AudioNode, or ToneAudioNode
                * @param destination The output to connect to
                * @param outputNum The output to connect from
                * @param inputNum The input to connect to
                */
            connect(destination: InputNode, outputNum?: number, inputNum?: number): this;
            /**
                * Connect the output to the context's destination node.
                */
            toDestination(): this;
            /**
                * Connect the output to the context's destination node.
                * alias for {@link toDestination}
                * @deprecated
                */
            toMaster(): this;
            /**
                * disconnect the output
                */
            disconnect(destination?: InputNode, outputNum?: number, inputNum?: number): this;
            /**
                * Connect the output of this node to the rest of the nodes in series.
                * @example
                * //connect a node to an effect, panVol and then to the master output
                * node.chain(effect, panVol, Tone.Destination);
                */
            chain(...nodes: InputNode[]): this;
            /**
                * connect the output of this node to the rest of the nodes in parallel.
                */
            fan(...nodes: InputNode[]): this;
            /**
                * Dispose and disconnect
                */
            dispose(): this;
    }
    /**
        * connect together all of the arguments in series
        * @param nodes
        */
    export function connectSeries(...nodes: InputNode[]): void;
    /**
        * Connect two nodes together so that signal flows from the
        * first node to the second. Optionally specify the input and output channels.
        * @param srcNode The source node
        * @param dstNode The destination node
        * @param outputNumber The output channel of the srcNode
        * @param inputNumber The input channel of the dstNode
        */
    export function connect(srcNode: OutputNode, dstNode: InputNode, outputNumber?: number, inputNumber?: number): void;
    /**
        * Disconnect a node from all nodes or optionally include a destination node and input/output channels.
        * @param srcNode The source node
        * @param dstNode The destination node
        * @param outputNumber The output channel of the srcNode
        * @param inputNumber The input channel of the dstNode
        */
    export function disconnect(srcNode: OutputNode, dstNode?: InputNode, outputNumber?: number, inputNumber?: number): void;
}

declare module 'tone/core/context/Param' {
    import { AbstractParam } from "tone/core/context/AbstractParam";
    import { Positive, Time, Unit, UnitName } from "tone/core/type/Units";
    import { Timeline } from "tone/core/util/Timeline";
    import { ToneWithContext, ToneWithContextOptions } from "tone/core/context/ToneWithContext";
    export interface ParamOptions<Type> extends ToneWithContextOptions {
            units: UnitName;
            value?: Type;
            param: AudioParam | Param<Type>;
            convert: boolean;
            minValue?: number;
            maxValue?: number;
            swappable?: boolean;
    }
    /**
        * the possible automation types
        */
    type AutomationType = "linearRampToValueAtTime" | "exponentialRampToValueAtTime" | "setValueAtTime" | "setTargetAtTime" | "cancelScheduledValues";
    interface TargetAutomationEvent {
            type: "setTargetAtTime";
            time: number;
            value: number;
            constant: number;
    }
    interface NormalAutomationEvent {
            type: Exclude<AutomationType, "setTargetAtTime">;
            time: number;
            value: number;
    }
    /**
        * The events on the automation
        */
    export type AutomationEvent = NormalAutomationEvent | TargetAutomationEvent;
    /**
        * Param wraps the native Web Audio's AudioParam to provide
        * additional unit conversion functionality. It also
        * serves as a base-class for classes which have a single,
        * automatable parameter.
        */
    export class Param<Type extends Unit = number> extends ToneWithContext<ParamOptions<Type>> implements AbstractParam<Type> {
            readonly name: string;
            readonly input: GainNode | AudioParam;
            readonly units: UnitName;
            convert: boolean;
            overridden: boolean;
            /**
                * The timeline which tracks all of the automations.
                */
            protected _events: Timeline<AutomationEvent>;
            /**
                * The native parameter to control
                */
            protected _param: AudioParam;
            /**
                * The default value before anything is assigned
                */
            protected _initialValue: number;
            /**
                * If the underlying AudioParam can be swapped out
                * using the setParam method.
                */
            protected readonly _swappable: boolean;
            /**
                * @param param The AudioParam to wrap
                * @param units The unit name
                * @param convert Whether or not to convert the value to the target units
                */
            constructor(param: AudioParam, units?: Unit, convert?: boolean);
            constructor(options: Partial<ParamOptions<Type>>);
            static getDefaults(): ParamOptions<any>;
            value: Type;
            readonly minValue: number;
            readonly maxValue: number;
            /**
                * Convert the given value from the type specified by Param.units
                * into the destination value (such as Gain or Frequency).
                */
            protected _fromType(val: Type): number;
            /**
                * Convert the parameters value into the units specified by Param.units.
                */
            protected _toType(val: number): Type;
            setValueAtTime(value: Type, time: Time): this;
            getValueAtTime(time: Time): Type;
            setRampPoint(time: Time): this;
            linearRampToValueAtTime(value: Type, endTime: Time): this;
            exponentialRampToValueAtTime(value: Type, endTime: Time): this;
            exponentialRampTo(value: Type, rampTime: Time, startTime?: Time): this;
            linearRampTo(value: Type, rampTime: Time, startTime?: Time): this;
            targetRampTo(value: Type, rampTime: Time, startTime?: Time): this;
            exponentialApproachValueAtTime(value: Type, time: Time, rampTime: Time): this;
            setTargetAtTime(value: Type, startTime: Time, timeConstant: Positive): this;
            setValueCurveAtTime(values: Type[], startTime: Time, duration: Time, scaling?: number): this;
            cancelScheduledValues(time: Time): this;
            cancelAndHoldAtTime(time: Time): this;
            rampTo(value: Type, rampTime?: Time, startTime?: Time): this;
            /**
                * Apply all of the previously scheduled events to the passed in Param or AudioParam.
                * The applied values will start at the context's current time and schedule
                * all of the events which are scheduled on this Param onto the passed in param.
                */
            apply(param: Param | AudioParam): this;
            /**
                * Replace the Param's internal AudioParam. Will apply scheduled curves
                * onto the parameter and replace the connections.
                */
            setParam(param: AudioParam): this;
            dispose(): this;
            readonly defaultValue: Type;
            protected _exponentialApproach(t0: number, v0: number, v1: number, timeConstant: number, t: number): number;
            protected _linearInterpolate(t0: number, v0: number, t1: number, v1: number, t: number): number;
            protected _exponentialInterpolate(t0: number, v0: number, t1: number, v1: number, t: number): number;
    }
    export {};
}

declare module 'tone/core/context/Gain' {
    import { Param } from "tone/core/context/Param";
    import { GainFactor, Unit, UnitName } from "tone/core/type/Units";
    import { ToneAudioNode, ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    interface GainOptions extends ToneAudioNodeOptions {
            gain: number;
            units: UnitName;
            convert: boolean;
    }
    /**
        * A thin wrapper around the Native Web Audio GainNode.
        * The GainNode is a basic building block of the Web Audio
        * API and is useful for routing audio and adjusting gains.
        * @category Core
        */
    export class Gain<Type extends Unit = GainFactor> extends ToneAudioNode<GainOptions> {
            readonly name: string;
            /**
                * The gain parameter of the gain node.
                */
            readonly gain: Param<Type>;
            readonly input: GainNode;
            readonly output: GainNode;
            /**
                * @param  gain The initial gain of the GainNode
                * @param units The units of the gain parameter.
                */
            constructor(gain?: GainFactor, units?: Unit);
            constructor(options?: Partial<GainOptions>);
            static getDefaults(): GainOptions;
            /**
                * Clean up.
                */
            dispose(): this;
    }
    export {};
}

declare module 'tone/core/context/OfflineContext' {
    import { Context } from "tone/core/context/Context";
    import { Seconds } from "tone/core/type/Units";
    import { ToneAudioBuffer } from "tone/core/context/ToneAudioBuffer";
    /**
        * Wrapper around the OfflineAudioContext
        * @category Core
        */
    export class OfflineContext extends Context {
            readonly name: string;
            /**
                * Private reference to the OfflineAudioContext.
                */
            protected _context: OfflineAudioContext;
            readonly isOffline: boolean;
            /**
                * @param  channels  The number of channels to render
                * @param  duration  The duration to render in seconds
                * @param sampleRate the sample rate to render at
                */
            constructor(channels: number, duration: Seconds, sampleRate: number);
            constructor(context: OfflineAudioContext);
            /**
                * Override the now method to point to the internal clock time
                */
            now(): Seconds;
            /**
                * Same as this.now()
                */
            readonly currentTime: Seconds;
            /**
                * Render the output of the OfflineContext
                * @param asynchronous If the clock should be rendered asynchronously, which will not block the main thread, but be slightly slower.
                */
            render(asynchronous?: boolean): Promise<ToneAudioBuffer>;
            /**
                * Close the context
                */
            close(): Promise<void>;
    }
}

declare module 'tone/core/context/Offline' {
    import { Seconds } from "tone/core/type/Units";
    import { OfflineContext } from "tone/core/context/OfflineContext";
    import { ToneAudioBuffer } from "tone/core/context/ToneAudioBuffer";
    /**
      * Generate a buffer by rendering all of the Tone.js code within the callback using the OfflineAudioContext.
      * The OfflineAudioContext is capable of rendering much faster than real time in many cases.
      * The callback function also passes in an offline instance of [[Context]] which can be used
      * to schedule events along the Transport.
      * @param  callback  All Tone.js nodes which are created and scheduled within this callback are recorded into the output Buffer.
      * @param  duration     the amount of time to record for.
      * @return  The promise which is invoked with the ToneAudioBuffer of the recorded output.
      * @example
      * //render 2 seconds of the oscillator
      * Tone.Offline(() => {
      * 	//only nodes created in this callback will be recorded
      * 	var oscillator = new Tone.Oscillator().toDestination().start(0)
      * 	//schedule their events
      * }, 2).then((buffer) => {
      * 	//do something with the output buffer
      * })
      * @example
      * //can also schedule events along the Transport
      * //using the passed in Offline Transport
      * Tone.Offline(({ transport }) => {
      * 	var osc = new Tone.Oscillator().toDestination()
      * 	transport.schedule(function(time){
      * 		osc.start(time).stop(time + 0.1)
      * 	}, 1)
      * 	transport.start(0.2)
      * }, 4).then((buffer) => {
      * 	//do something with the output buffer
      * })
      * @category Core
      */
    export function Offline(callback: (context: OfflineContext) => Promise<void> | void, duration: Seconds, channels?: number, sampleRate?: number): Promise<ToneAudioBuffer>;
}

declare module 'tone/core/context/ToneAudioBuffer' {
    import { Tone } from "tone/core/Tone";
    import { Samples, Seconds } from "tone/core/type/Units";
    interface ToneAudioBufferOptions {
            url?: string | AudioBuffer | ToneAudioBuffer;
            reverse: boolean;
            onload: (buffer?: ToneAudioBuffer) => void;
            onerror: (error: Error) => void;
    }
    /**
        * AudioBuffer loading and storage. ToneAudioBuffer is used internally by all
        * classes that make requests for audio files such as Tone.Player,
        * Tone.Sampler and Tone.Convolver.
        *
        * Aside from load callbacks from individual buffers, ToneAudioBuffer
        * provides events which keep track of the loading progress
        * of _all_ of the buffers. These are ToneAudioBuffer.on("load" / "progress" / "error")
        * @example
        * var buffer = new ToneAudioBuffer("path/to/sound.mp3", function(){
        * 	//the buffer is now available.
        * 	var buff = buffer.get();
        * });
        * @example
        * //can load provide fallback extension types if the first type is not supported.
        * var buffer = new ToneAudioBuffer("path/to/sound.[mp3|ogg|wav]");
        * @category Core
        */
    export class ToneAudioBuffer extends Tone {
            readonly name: string;
            /**
                * Callback when the buffer is loaded.
                */
            onload: (buffer: ToneAudioBuffer) => void;
            /**
                *
                * @param url The url to load, or the audio buffer to set.
                * @param onload A callback which is invoked after the buffer is loaded.
                *                           It's recommended to use `ToneAudioBuffer.on('load', callback)` instead
                *                           since it will give you a callback when _all_ buffers are loaded.
                * @param onerror The callback to invoke if there is an error
                */
            constructor(url?: string | ToneAudioBuffer | AudioBuffer, onload?: (buffer: ToneAudioBuffer) => void, onerror?: (error: Error) => void);
            constructor(options?: Partial<ToneAudioBufferOptions>);
            static getDefaults(): ToneAudioBufferOptions;
            /**
                * The sample rate of the AudioBuffer
                */
            readonly sampleRate: number;
            /**
                * Pass in an AudioBuffer or ToneAudioBuffer to set the value of this buffer.
                */
            set(buffer: AudioBuffer | ToneAudioBuffer): this;
            /**
                * The audio buffer stored in the object.
                */
            get(): AudioBuffer | undefined;
            /**
                * Makes an fetch request for the selected url then decodes the file as an audio buffer.
                * Invokes the callback once the audio buffer loads.
                * @param url The url of the buffer to load. filetype support depends on the browser.
                * @returns A Promise which resolves with this ToneAudioBuffer
                */
            load(url: string): Promise<this>;
            /**
                * clean up
                */
            dispose(): this;
            /**
                * Set the audio buffer from the array.
                * To create a multichannel AudioBuffer, pass in a multidimensional array.
                * @param array The array to fill the audio buffer
                */
            fromArray(array: Float32Array | Float32Array[]): this;
            /**
                * Sums multiple channels into 1 channel
                * @param chanNum Optionally only copy a single channel from the array.
                */
            toMono(chanNum?: number): this;
            /**
                * Get the buffer as an array. Single channel buffers will return a 1-dimensional
                * Float32Array, and multichannel buffers will return multidimensional arrays.
                * @param channel Optionally only copy a single channel from the array.
                */
            toArray(channel?: number): Float32Array | Float32Array[];
            /**
                * Returns the Float32Array representing the PCM audio data for the specific channel.
                * @param  channel  The channel number to return
                * @return The audio as a TypedArray
                */
            getChannelData(channel: number): Float32Array;
            /**
                * Cut a subsection of the array and return a buffer of the
                * subsection. Does not modify the original buffer
                * @param start The time to start the slice
                * @param end The end time to slice. If none is given will default to the end of the buffer
                */
            slice(start: Seconds, end?: Seconds): ToneAudioBuffer;
            /**
                * If the buffer is loaded or not
                */
            readonly loaded: boolean;
            /**
                * The duration of the buffer in seconds.
                */
            readonly duration: Seconds;
            /**
                * The length of the buffer in samples
                */
            readonly length: Samples;
            /**
                * The number of discrete audio channels. Returns 0 if no buffer is loaded.
                */
            readonly numberOfChannels: number;
            /**
                * Reverse the buffer.
                */
            reverse: boolean;
            /**
                * A path which is prefixed before every url.
                */
            static baseUrl: string;
            /**
                * Create a ToneAudioBuffer from the array. To create a multichannel AudioBuffer,
                * pass in a multidimensional array.
                * @param array The array to fill the audio buffer
                * @return A ToneAudioBuffer created from the array
                */
            static fromArray(array: Float32Array | Float32Array[]): ToneAudioBuffer;
            /**
                * Creates a ToneAudioBuffer from a URL, returns a promise which resolves to a ToneAudioBuffer
                * @param  url The url to load.
                * @return A promise which resolves to a ToneAudioBuffer
                */
            static fromUrl(url: string): Promise<ToneAudioBuffer>;
            /**
                * All of the downloads
                */
            static downloads: Array<Promise<AudioBuffer>>;
            /**
                * Loads a url using fetch and returns the AudioBuffer.
                */
            static load(url: string): Promise<AudioBuffer>;
            /**
                * Checks a url's extension to see if the current browser can play that file type.
                * @param url The url/extension to test
                * @return If the file extension can be played
                * @static
                * @example
                * ToneAudioBuffer.supportsType("wav"); //returns true
                * ToneAudioBuffer.supportsType("path/to/file.wav"); //returns true
                */
            static supportsType(url: string): boolean;
            /**
                * Returns a Promise which resolves when all of the buffers have loaded
                */
            static loaded(): Promise<void>;
    }
    export {};
}

declare module 'tone/core/context/ToneAudioBuffers' {
    import { Tone } from "tone/core/Tone";
    import { ToneAudioBuffer } from "tone/core/context/ToneAudioBuffer";
    export interface ToneAudioBuffersUrlMap {
            [name: string]: string | AudioBuffer | ToneAudioBuffer;
            [name: number]: string | AudioBuffer | ToneAudioBuffer;
    }
    interface ToneAudioBuffersOptions {
            urls: ToneAudioBuffersUrlMap;
            onload: () => void;
            onerror?: (error: Error) => void;
            baseUrl: string;
    }
    /**
        * A data structure for holding multiple buffers in a Map-like datastructure.
        *
        * @example
        * //load a whole bank of piano samples
        * var pianoSamples = new ToneAudioBuffers({
        * 	"C4" : "path/to/C4.mp3"
        * 	"C#4" : "path/to/C#4.mp3"
        * 	"D4" : "path/to/D4.mp3"
        * 	"D#4" : "path/to/D#4.mp3"
        * }, function(){
        * 	//play one of the samples when they all load
        * 	player.buffer = pianoSamples.get("C4");
        * 	player.start();
        * });
        * @example
        * //To pass in additional parameters in the second parameter
        * var buffers = new ToneAudioBuffers(urls, {
        * 	"onload" : callback,
        * 	"baseUrl" : "../path/to/audio/"
        * })
        * @category Core
        */
    export class ToneAudioBuffers extends Tone {
            readonly name: string;
            /**
                * A path which is prefixed before every url.
                */
            baseUrl: string;
            /**
                * @param  urls  An object literal or array of urls to load.
                * @param onload  The callback to invoke when the buffers are loaded.
                * @param baseUrl A prefix url to add before all the urls
                */
            constructor(urls?: ToneAudioBuffersUrlMap, onload?: () => void, baseUrl?: string);
            constructor(options?: Partial<ToneAudioBuffersOptions>);
            static getDefaults(): ToneAudioBuffersOptions;
            /**
                * True if the buffers object has a buffer by that name.
                * @param  name  The key or index of the buffer.
                */
            has(name: string | number): boolean;
            /**
                * Get a buffer by name. If an array was loaded,
                * then use the array index.
                * @param  name  The key or index of the buffer.
                */
            get(name: string | number): ToneAudioBuffer;
            /**
                * If the buffers are loaded or not
                */
            readonly loaded: boolean;
            /**
                * Add a buffer by name and url to the Buffers
                * @param  name      A unique name to give the buffer
                * @param  url  Either the url of the bufer, or a buffer which will be added with the given name.
                * @param  callback  The callback to invoke when the url is loaded.
                */
            add(name: string | number, url: string | AudioBuffer | ToneAudioBuffer, callback?: () => void): this;
            dispose(): this;
    }
    export {};
}

declare module 'tone/core/context/Delay' {
    import { Param } from "tone/core/context/Param";
    import { Time } from "tone/core/type/Units";
    import { ToneAudioNode, ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    export interface DelayOptions extends ToneAudioNodeOptions {
            delayTime: Time;
            maxDelay: Time;
    }
    /**
        * Wrapper around Web Audio's native [DelayNode](http://webaudio.github.io/web-audio-api/#the-delaynode-interface).
        * @category Core
        */
    export class Delay extends ToneAudioNode<DelayOptions> {
            readonly name: string;
            /**
                * The maximum delay time. This cannot be changed after
                * the value is passed into the constructor.
                */
            readonly maxDelay: Time;
            /**
                * The amount of time the incoming signal is delayed.
                */
            readonly delayTime: Param<Time>;
            readonly input: DelayNode;
            readonly output: DelayNode;
            /**
                * @param delayTime The delay applied to the incoming signal.
                * @param maxDelay The maximum delay time.
                */
            constructor(delayTime?: Time, maxDelay?: Time);
            constructor(options?: Partial<DelayOptions>);
            static getDefaults(): DelayOptions;
            /**
                * Clean up.
                */
            dispose(): this;
    }
}

declare module 'tone/core/clock/Clock' {
    import { ToneWithContext, ToneWithContextOptions } from "tone/core/context/ToneWithContext";
    import { BPM, Frequency, Hertz, Seconds, Ticks, Time } from "tone/core/type/Units";
    import { Emitter } from "tone/core/util/Emitter";
    import { PlaybackState } from "tone/core/util/StateTimeline";
    import { TickSignal } from "tone/core/clock/TickSignal";
    type ClockCallback = (time: Time, ticks?: Ticks) => void;
    interface ClockOptions extends ToneWithContextOptions {
            frequency: Hertz;
            callback: ClockCallback;
            units: "hertz" | "bpm";
    }
    type ClockEvent = "start" | "stop" | "pause";
    /**
        * A sample accurate clock which provides a callback at the given rate.
        * While the callback is not sample-accurate (it is still susceptible to
        * loose JS timing), the time passed in as the argument to the callback
        * is precise. For most applications, it is better to use Tone.Transport
        * instead of the Clock by itself since you can synchronize multiple callbacks.
        * @example
        * // the callback will be invoked approximately once a second
        * // and will print the time exactly once a second apart.
        * const clock = new Tone.Clock(time => {
        * 	console.log(time);
        * }, 1);
        * @category Core
        */
    export class Clock<Type extends BPM | Hertz = Hertz> extends ToneWithContext<ClockOptions> implements Emitter<ClockEvent> {
            readonly name: string;
            /**
                * The callback function to invoke at the scheduled tick.
                */
            callback: ClockCallback;
            /**
                * The rate the callback function should be invoked.
                */
            frequency: TickSignal<Type>;
            /**
                * @param callback The callback to be invoked with the time of the audio event
                * @param frequency The rate of the callback
                */
            constructor(callback?: ClockCallback, frequency?: Frequency);
            constructor(options: Partial<ClockOptions>);
            static getDefaults(): ClockOptions;
            /**
                * Returns the playback state of the source, either "started", "stopped" or "paused".
                */
            readonly state: PlaybackState;
            /**
                * Start the clock at the given time. Optionally pass in an offset
                * of where to start the tick counter from.
                * @param  time    The time the clock should start
                * @param offset  Where the tick counter starts counting from.
                */
            start(time?: Time, offset?: Ticks): this;
            /**
                * Stop the clock. Stopping the clock resets the tick counter to 0.
                * @param time The time when the clock should stop.
                * @example
                * clock.stop();
                */
            stop(time?: Time): this;
            /**
                * Pause the clock. Pausing does not reset the tick counter.
                * @param time The time when the clock should stop.
                */
            pause(time?: Time): this;
            /**
                * The number of times the callback was invoked. Starts counting at 0
                * and increments after the callback was invoked.
                */
            ticks: Ticks;
            /**
                * The time since ticks=0 that the Clock has been running. Accounts for tempo curves
                */
            seconds: Seconds;
            /**
                * Return the elapsed seconds at the given time.
                * @param  time  When to get the elapsed seconds
                * @return  The number of elapsed seconds
                */
            getSecondsAtTime(time: Time): Seconds;
            /**
                * Set the clock's ticks at the given time.
                * @param  ticks The tick value to set
                * @param  time  When to set the tick value
                */
            setTicksAtTime(ticks: Ticks, time: Time): this;
            /**
                * Get the clock's ticks at the given time.
                * @param  time  When to get the tick value
                * @return The tick value at the given time.
                */
            getTicksAtTime(time?: Time): Ticks;
            /**
                * Get the time of the next tick
                * @param  offset The tick number.
                */
            nextTickTime(offset: Ticks, when: Time): Seconds;
            /**
                * Returns the scheduled state at the given time.
                * @param  time  The time to query.
                * @return  The name of the state input in setStateAtTime.
                * @example
                * const clock = new Tone.Clock();
                * clock.start("+0.1");
                * clock.getStateAtTime("+0.1"); // returns "started"
                */
            getStateAtTime(time: Time): PlaybackState;
            /**
                * Clean up
                */
            dispose(): this;
            on: (event: ClockEvent, callback: (...args: any[]) => void) => this;
            once: (event: ClockEvent, callback: (...args: any[]) => void) => this;
            off: (event: ClockEvent, callback?: ((...args: any[]) => void) | undefined) => this;
            emit: (event: any, ...args: any[]) => this;
    }
    export {};
}

declare module 'tone/core/type/Frequency' {
    import { TimeClass } from "tone/core/type/Time";
    import { TimeBaseUnit, TimeExpression, TimeValue } from "tone/core/type/TimeBase";
    import { Frequency, Hertz, Interval, MidiNote, Note, Seconds, Ticks } from "tone/core/type/Units";
    export type FrequencyUnit = TimeBaseUnit | "midi";
    /**
        * Frequency is a primitive type for encoding Frequency values.
        * Eventually all time values are evaluated to hertz using the `eval` method.
        * @example
        * Frequency("C3") // 261
        * Frequency(38, "midi") //
        * Frequency("C3").transpose(4);
        * @category Unit
        */
    export class FrequencyClass<Type extends number = Hertz> extends TimeClass<Type, FrequencyUnit> {
            readonly name: string;
            readonly defaultUnits: FrequencyUnit;
            /**
                * The [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used
                * to generate all the other pitch values from notes. A4's values in Hertz.
                */
            static A4: Hertz;
            protected _getExpressions(): TimeExpression<Type>;
            /**
                * Transposes the frequency by the given number of semitones.
                * @return  A new transposed frequency
                * @example
                * Frequency("A4").transpose(3); //"C5"
                */
            transpose(interval: Interval): FrequencyClass;
            /**
                * Takes an array of semitone intervals and returns
                * an array of frequencies transposed by those intervals.
                * @return  Returns an array of Frequencies
                * @example
                * Frequency("A4").harmonize([0, 3, 7]); //["A4", "C5", "E5"]
                */
            harmonize(intervals: Interval[]): FrequencyClass[];
            /**
                * Return the value of the frequency as a MIDI note
                * @example
                * Frequency("C4").toMidi(); //60
                */
            toMidi(): MidiNote;
            /**
                * Return the value of the frequency in Scientific Pitch Notation
                * @example
                * Frequency(69, "midi").toNote(); //"A4"
                */
            toNote(): Note;
            /**
                * Return the duration of one cycle in seconds.
                */
            toSeconds(): Seconds;
            /**
                * Return the duration of one cycle in ticks
                */
            toTicks(): Ticks;
            /**
                * With no arguments, return 0
                */
            protected _noArg(): Type;
            /**
                * Returns the value of a frequency in the current units
                */
            protected _frequencyToUnits(freq: Hertz): Type;
            /**
                * Returns the value of a tick in the current time units
                */
            protected _ticksToUnits(ticks: Ticks): Type;
            /**
                * Return the value of the beats in the current units
                */
            protected _beatsToUnits(beats: number): Type;
            /**
                * Returns the value of a second in the current units
                */
            protected _secondsToUnits(seconds: Seconds): Type;
            /**
                * Convert a MIDI note to frequency value.
                * @param  midi The midi number to convert.
                * @return The corresponding frequency value
                * @example
                * FrequencyClass.mtof(69); // returns 440
                */
            static mtof(midi: MidiNote): Hertz;
            /**
                * Convert a frequency value to a MIDI note.
                * @param frequency The value to frequency value to convert.
                * @example
                * Frequency.ftom(440); // returns 69
                */
            static ftom(frequency: Hertz): MidiNote;
    }
    /**
        * Convert a value into a FrequencyClass object.
        * @category Unit
        */
    export function Frequency(value?: TimeValue | Frequency, units?: FrequencyUnit): FrequencyClass;
}

declare module 'tone/core/type/Time' {
    import { TimeBaseClass, TimeBaseUnit, TimeExpression, TimeValue } from "tone/core/type/TimeBase";
    import { BarsBeatsSixteenths, MidiNote, Seconds, Subdivision, Ticks, Time } from "tone/core/type/Units";
    /**
        * TimeClass is a primitive type for encoding and decoding Time values.
        * TimeClass can be passed into the parameter of any method which takes time as an argument.
        * @param  val    The time value.
        * @param  units  The units of the value.
        * @example
        * var t = Time("4n");//a quarter note
        * @category Unit
        */
    export class TimeClass<Type extends Seconds | Ticks = Seconds, Unit extends string = TimeBaseUnit> extends TimeBaseClass<Type, Unit> {
            readonly name: string;
            protected _getExpressions(): TimeExpression<Type>;
            /**
                * Quantize the time by the given subdivision. Optionally add a
                * percentage which will move the time value towards the ideal
                * quantized value by that percentage.
                * @param  subdiv    The subdivision to quantize to
                * @param  percent  Move the time value towards the quantized value by a percentage.
                * @example
                * Time(21).quantize(2) //returns 22
                * Time(0.6).quantize("4n", 0.5) //returns 0.55
                */
            quantize(subdiv: Time, percent?: number): Type;
            /**
                * Convert a Time to Notation. The notation values are will be the
                * closest representation between 1m to 128th note.
                * @return {Notation}
                * @example
                * //if the Transport is at 120bpm:
                * Time(2).toNotation();//returns "1m"
                */
            toNotation(): Subdivision;
            /**
                * Return the time encoded as Bars:Beats:Sixteenths.
                */
            toBarsBeatsSixteenths(): BarsBeatsSixteenths;
            /**
                * Return the time in ticks.
                */
            toTicks(): Ticks;
            /**
                * Return the time in seconds.
                */
            toSeconds(): Seconds;
            /**
                * Return the value as a midi note.
                */
            toMidi(): MidiNote;
            protected _now(): Type;
    }
    /**
        * Create a TimeClass from a time string or number.
        * @param value A value which reprsents time
        * @param units The value's units if they can't be inferred by the value.
        * @category Unit
        */
    export function Time(value?: TimeValue, units?: TimeBaseUnit): TimeClass<Seconds>;
}

declare module 'tone/core/type/Ticks' {
    import { TimeBaseUnit, TimeValue } from "tone/core/type/TimeBase";
    import { TransportTimeClass } from "tone/core/type/TransportTime";
    import { Seconds, Ticks } from "tone/core/type/Units";
    /**
        * Ticks is a primitive type for encoding Time values.
        * Ticks can be constructed with or without the `new` keyword. Ticks can be passed
        * into the parameter of any method which takes time as an argument.
        * @example
        * const t = Ticks("4n"); //a quarter note as ticks
        * @category Unit
        */
    export class TicksClass extends TransportTimeClass<Ticks> {
            readonly name: string;
            readonly defaultUnits: TimeBaseUnit;
            /**
                * Get the current time in the given units
                */
            protected _now(): Ticks;
            /**
                * Return the value of the beats in the current units
                */
            protected _beatsToUnits(beats: number): Ticks;
            /**
                * Returns the value of a second in the current units
                */
            protected _secondsToUnits(seconds: Seconds): Ticks;
            /**
                * Returns the value of a tick in the current time units
                */
            protected _ticksToUnits(ticks: Ticks): Ticks;
            /**
                * Return the time in ticks
                */
            toTicks(): Ticks;
            /**
                * Return the time in seconds
                */
            toSeconds(): Seconds;
    }
    /**
        * Convert a time representation to ticks
        * @category Unit
        */
    export function Ticks(value?: TimeValue, units?: TimeBaseUnit): TicksClass;
}

declare module 'tone/core/type/Midi' {
    import { FrequencyClass, FrequencyUnit } from "tone/core/type/Frequency";
    import { TimeValue } from "tone/core/type/TimeBase";
    import { Hertz, Interval, MidiNote, Seconds, Ticks } from "tone/core/type/Units";
    /**
        * Midi is a primitive type for encoding Time values.
        * Midi can be constructed with or without the `new` keyword. Midi can be passed
        * into the parameter of any method which takes time as an argument.
        * @example
        * var t = Midi("4n");//a quarter note
        * @category Unit
        */
    export class MidiClass extends FrequencyClass<MidiNote> {
            readonly name: string;
            readonly defaultUnits = "midi";
            /**
                * Returns the value of a frequency in the current units
                */
            protected _frequencyToUnits(freq: Hertz): MidiNote;
            /**
                * Returns the value of a tick in the current time units
                */
            protected _ticksToUnits(ticks: Ticks): MidiNote;
            /**
                * Return the value of the beats in the current units
                */
            protected _beatsToUnits(beats: number): MidiNote;
            /**
                * Returns the value of a second in the current units
                */
            protected _secondsToUnits(seconds: Seconds): MidiNote;
            /**
                * Return the value of the frequency as a MIDI note
                * @return  {MIDI}
                * @example
                * Midi(60).toMidi(); //60
                */
            toMidi(): MidiNote;
            /**
                * Return the value of the frequency as a MIDI note
                * @return  {MIDI}
                * @example
                * Midi(60).toFrequency(); //261.6255653005986
                */
            toFrequency(): Hertz;
            /**
                * Transposes the frequency by the given number of semitones.
                * @return A new transposed MidiClass
                * @example
                * Midi("A4").transpose(3); //"C5"
                */
            transpose(interval: Interval): MidiClass;
    }
    /**
        * Convert a value into a FrequencyClass object.
        * @category Unit
        */
    export function Midi(value?: TimeValue, units?: FrequencyUnit): MidiClass;
}

declare module 'tone/core/type/TransportTime' {
    import { Seconds, Ticks } from "tone/core/type/Units";
    import { TimeClass } from "tone/core/type/Time";
    import { TimeBaseUnit, TimeValue } from "tone/core/type/TimeBase";
    /**
        * TransportTime is a the time along the Transport's
        * timeline. It is similar to Tone.Time, but instead of evaluating
        * against the AudioContext's clock, it is evaluated against
        * the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).
        * @category Unit
        */
    export class TransportTimeClass<Type extends Seconds | Ticks = Seconds> extends TimeClass<Type> {
            readonly name: string;
            /**
                * Return the current time in whichever context is relevant
                */
            protected _now(): Type;
    }
    /**
        * TransportTime is a the time along the Transport's
        * timeline. It is similar to [[Time]], but instead of evaluating
        * against the AudioContext's clock, it is evaluated against
        * the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).
        * @category Unit
        */
    export function TransportTime(value?: TimeValue, units?: TimeBaseUnit): TransportTimeClass;
}

declare module 'tone/core/util/Draw' {
    import { ToneWithContext, ToneWithContextOptions } from "tone/core/context/ToneWithContext";
    import { Seconds, Time } from "tone/core/type/Units";
    /**
        * Draw is useful for synchronizing visuals and audio events.
        * Callbacks from Tone.Transport or any of the Tone.Event classes
        * always happen _before_ the scheduled time and are not synchronized
        * to the animation frame so they are not good for triggering tightly
        * synchronized visuals and sound. Draw makes it easy to schedule
        * callbacks using the AudioContext time and uses requestAnimationFrame.
        * @example
        * Tone.Transport.schedule(function(time){
        * 	//use the time argument to schedule a callback with Draw
        * 	Draw.schedule(function(){
        * 		//do drawing or DOM manipulation here
        * 	}, time)
        * }, "+0.5")
        * @category Core
        */
    export class Draw extends ToneWithContext<ToneWithContextOptions> {
            readonly name: string;
            /**
                * The duration after which events are not invoked.
                */
            expiration: Seconds;
            /**
                * The amount of time before the scheduled time
                * that the callback can be invoked. Default is
                * half the time of an animation frame (0.008 seconds).
                */
            anticipation: Seconds;
            /**
                * Schedule a function at the given time to be invoked
                * on the nearest animation frame.
                * @param  callback  Callback is invoked at the given time.
                * @param  time      The time relative to the AudioContext time to invoke the callback.
                */
            schedule(callback: () => void, time: Time): this;
            /**
                * Cancel events scheduled after the given time
                * @param  after  Time after which scheduled events will be removed from the scheduling timeline.
                */
            cancel(after?: Time): this;
            dispose(): this;
    }
}

declare module 'tone/core/util/StateTimeline' {
    import { Seconds } from "tone/core/type/Units";
    import { Timeline, TimelineEvent } from "tone/core/util/Timeline";
    export type BasicPlaybackState = "started" | "stopped";
    export type PlaybackState = BasicPlaybackState | "paused";
    export interface StateTimelineEvent extends TimelineEvent {
            state: PlaybackState;
    }
    /**
        * A Timeline State. Provides the methods: `setStateAtTime("state", time)` and `getValueAtTime(time)`
        * @param initial The initial state of the StateTimeline.  Defaults to `undefined`
        */
    export class StateTimeline<AdditionalOptions extends {} = {}> extends Timeline<StateTimelineEvent & AdditionalOptions> {
            readonly name: string;
            constructor(initial?: PlaybackState);
            /**
                * Returns the scheduled state scheduled before or at
                * the given time.
                * @param  time  The time to query.
                * @return  The name of the state input in setStateAtTime.
                */
            getValueAtTime(time: Seconds): PlaybackState;
            /**
                * Add a state to the timeline.
                * @param  state The name of the state to set.
                * @param  time  The time to query.
                * @param options Any additional options that are needed in the timeline.
                */
            setStateAtTime(state: PlaybackState, time: Seconds, options?: AdditionalOptions): this;
            /**
                * Return the event before the time with the given state
                * @param  state The state to look for
                * @param  time  When to check before
                * @return  The event with the given state before the time
                */
            getLastState(state: PlaybackState, time: number): StateTimelineEvent & AdditionalOptions | undefined;
            /**
                * Return the event after the time with the given state
                * @param  state The state to look for
                * @param  time  When to check from
                * @return  The event with the given state after the time
                */
            getNextState(state: PlaybackState, time: number): StateTimelineEvent & AdditionalOptions | undefined;
    }
}

declare module 'tone/core/util/IntervalTimeline' {
    import { Tone } from "tone/core/Tone";
    /**
        * An IntervalTimeline event must have a time and duration
        */
    export interface IntervalTimelineEvent {
            time: number;
            duration: number;
            [propName: string]: any;
    }
    type IteratorCallback = (event: IntervalTimelineEvent) => void;
    /**
        * Similar to Tone.Timeline, but all events represent
        * intervals with both "time" and "duration" times. The
        * events are placed in a tree structure optimized
        * for querying an intersection point with the timeline
        * events. Internally uses an [Interval Tree](https://en.wikipedia.org/wiki/Interval_tree)
        * to represent the data.
        */
    export class IntervalTimeline extends Tone {
            readonly name: string;
            /**
                * The event to add to the timeline. All events must
                * have a time and duration value
                * @param  event  The event to add to the timeline
                */
            add(event: IntervalTimelineEvent): this;
            /**
                * Remove an event from the timeline.
                * @param  event  The event to remove from the timeline
                */
            remove(event: IntervalTimelineEvent): this;
            /**
                * The number of items in the timeline.
                * @readOnly
                */
            readonly length: number;
            /**
                * Remove events whose time time is after the given time
                * @param  after  The time to query.
                */
            cancel(after: number): this;
            /**
                * Get an event whose time and duration span the give time. Will
                * return the match whose "time" value is closest to the given time.
                * @return  The event which spans the desired time
                */
            get(time: number): IntervalTimelineEvent | null;
            /**
                * Iterate over everything in the timeline.
                * @param  callback The callback to invoke with every item
                */
            forEach(callback: IteratorCallback): this;
            /**
                * Iterate over everything in the array in which the given time
                * overlaps with the time and duration time of the event.
                * @param  time The time to check if items are overlapping
                * @param  callback The callback to invoke with every item
                */
            forEachAtTime(time: number, callback: IteratorCallback): this;
            /**
                * Iterate over everything in the array in which the time is greater
                * than or equal to the given time.
                * @param  time The time to check if items are before
                * @param  callback The callback to invoke with every item
                */
            forEachFrom(time: number, callback: IteratorCallback): this;
            /**
                * Clean up
                */
            dispose(): this;
    }
    export {};
}

declare module 'tone/core/util/Timeline' {
    import { Tone } from "tone/core/Tone";
    import { Seconds } from "tone/core/type/Units";
    type TimelineSearchParam = "ticks" | "time";
    /**
        * The options object for Timeline
        */
    interface TimelineOptions {
            memory: number;
            increasing: boolean;
    }
    /**
        * An event must have a time number
        */
    export interface TimelineEvent {
            time: number;
    }
    /**
        * A Timeline class for scheduling and maintaining state
        * along a timeline. All events must have a "time" property.
        * Internally, events are stored in time order for fast
        * retrieval.
        */
    export class Timeline<GenericEvent extends TimelineEvent> extends Tone {
            readonly name: string;
            /**
                * The memory of the timeline, i.e.
                * how many events in the past it will retain
                */
            memory: number;
            /**
                * The array of scheduled timeline events
                */
            protected _timeline: GenericEvent[];
            /**
                * If the time value must always be greater than or equal to the last
                * element on the list.
                */
            increasing: boolean;
            /**
                * @param memory The number of previous events that are retained.
                */
            constructor(memory?: number);
            constructor(options?: Partial<TimelineOptions>);
            static getDefaults(): TimelineOptions;
            /**
                * The number of items in the timeline.
                */
            readonly length: number;
            /**
                * Insert an event object onto the timeline. Events must have a "time" attribute.
                * @param event  The event object to insert into the timeline.
                */
            add(event: GenericEvent): this;
            /**
                * Remove an event from the timeline.
                * @param  {Object}  event  The event object to remove from the list.
                * @returns {Timeline} this
                */
            remove(event: GenericEvent): this;
            /**
                * Get the nearest event whose time is less than or equal to the given time.
                * @param  time  The time to query.
                */
            get(time: number, param?: TimelineSearchParam): GenericEvent | null;
            /**
                * Return the first event in the timeline without removing it
                * @returns {Object} The first event object
                */
            peek(): GenericEvent | undefined;
            /**
                * Return the first event in the timeline and remove it
                */
            shift(): GenericEvent | undefined;
            /**
                * Get the event which is scheduled after the given time.
                * @param  time  The time to query.
                */
            getAfter(time: number, param?: TimelineSearchParam): GenericEvent | null;
            /**
                * Get the event before the event at the given time.
                * @param  time  The time to query.
                */
            getBefore(time: number): GenericEvent | null;
            /**
                * Cancel events at and after the given time
                * @param  after  The time to query.
                */
            cancel(after: number): this;
            /**
                * Cancel events before or equal to the given time.
                * @param  time  The time to cancel before.
                */
            cancelBefore(time: number): this;
            /**
                * Returns the previous event if there is one. null otherwise
                * @param  event The event to find the previous one of
                * @return The event right before the given event
                */
            previousEvent(event: GenericEvent): GenericEvent | null;
            /**
                * Does a binary search on the timeline array and returns the
                * nearest event index whose time is after or equal to the given time.
                * If a time is searched before the first index in the timeline, -1 is returned.
                * If the time is after the end, the index of the last item is returned.
                * @param  time
                */
            protected _search(time: number, param?: TimelineSearchParam): number;
            /**
                * Iterate over everything in the array
                * @param  callback The callback to invoke with every item
                */
            forEach(callback: (event: GenericEvent) => void): this;
            /**
                * Iterate over everything in the array at or before the given time.
                * @param  time The time to check if items are before
                * @param  callback The callback to invoke with every item
                */
            forEachBefore(time: Seconds, callback: (event: GenericEvent) => void): this;
            /**
                * Iterate over everything in the array after the given time.
                * @param  time The time to check if items are before
                * @param  callback The callback to invoke with every item
                */
            forEachAfter(time: Seconds, callback: (event: GenericEvent) => void): this;
            /**
                * Iterate over everything in the array between the startTime and endTime.
                * The timerange is inclusive of the startTime, but exclusive of the endTime.
                * range = [startTime, endTime).
                * @param  startTime The time to check if items are before
                * @param  endTime The end of the test interval.
                * @param  callback The callback to invoke with every item
                */
            forEachBetween(startTime: number, endTime: number, callback: (event: GenericEvent) => void): this;
            /**
                * Iterate over everything in the array at or after the given time. Similar to
                * forEachAfter, but includes the item(s) at the given time.
                * @param  time The time to check if items are before
                * @param  callback The callback to invoke with every item
                */
            forEachFrom(time: number, callback: (event: GenericEvent) => void): this;
            /**
                * Iterate over everything in the array at the given time
                * @param  time The time to check if items are before
                * @param  callback The callback to invoke with every item
                */
            forEachAtTime(time: number, callback: (event: GenericEvent) => void): this;
            /**
                * Clean up.
                */
            dispose(): this;
    }
    export {};
}

declare module 'tone/core/Tone' {
    export interface BaseToneOptions {
    }
    /**
        * @class  Tone is the base class of all other classes.
        * @constructor
        */
    export abstract class Tone {
            /**
                * The version number semver
                */
            static version: string;
            /**
                * The name of the class
                */
            protected abstract name: string;
            /**
                * Returns all of the default options belonging to the class.
                */
            static getDefaults(): BaseToneOptions;
            /**
                * Set this debug flag to log all events that happen in this class.
                */
            debug: boolean;
            /**
                * Prints the outputs to the console log for debugging purposes.
                * Prints the contents only if either the object has a property
                * called `debug` set to true, or a variable called TONE_DEBUG_CLASS
                * is set to the name of the class.
                * @example
                * //prints all logs originating from Tone.OscillatorNode
                * Tone.global.TONE_DEBUG_CLASS = "OscillatorNode"
                */
            protected log(...args: any[]): void;
            /**
                * Assert that the statement is true, otherwise invoke the error.
                * @param statement
                * @param error The message which is passed into an Error
                */
            protected assert(statement: boolean, error: string): void;
            /**
                * disconnect and dispose.
                */
            dispose(): this;
            /**
                * Indicates if the instance was disposed. 'Disposing' an
                * instance means that all of the Web Audio nodes that were
                * created for the instance are disconnected and freed for garbage collection.
                */
            readonly disposed: boolean;
            /**
                * Convert the class to a string
                * @example
                * const osc = new Oscillator()
                * osc.toString() // "Oscillator"
                */
            toString(): string;
    }
}

declare module 'tone/core/context/Destination' {
    import { Volume } from "tone/component/channel/Volume";
    import { Decibels } from "tone/core/type/Units";
    import { Gain } from "tone/core/context/Gain";
    import { Param } from "tone/core/context/Param";
    import { ToneAudioNode, ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    interface DestinationOptions extends ToneAudioNodeOptions {
            volume: Decibels;
            mute: boolean;
    }
    /**
        * A single master output which is connected to the
        * AudioDestinationNode (aka your speakers).
        * It provides useful conveniences such as the ability
        * to set the volume and mute the entire application.
        * It also gives you the ability to apply master effects to your application.
        *
        * @example
        * //the audio will go from the oscillator to the speakers
        * oscillator.connect(Destination);
        * //a convenience for connecting to the master output is also provided:
        * oscillator.toDestination();
        * //the above two examples are equivalent.
        * @category Core
        */
    export class Destination extends ToneAudioNode<DestinationOptions> {
            readonly name: string;
            input: Volume;
            output: Gain;
            /**
                * The volume of the master output.
                */
            volume: Param<Decibels>;
            constructor(options: Partial<DestinationOptions>);
            static getDefaults(): DestinationOptions;
            /**
                * Mute the output.
                * @example
                * //mute the output
                * Destination.mute = true;
                */
            mute: boolean;
            /**
                * Add a master effects chain. NOTE: this will disconnect any nodes which were previously
                * chained in the master effects chain.
                * @param args All arguments will be connected in a row and the Master will be routed through it.
                * @return  {Destination}  this
                * @example
                * //some overall compression to keep the levels in check
                * var masterCompressor = new Tone.Compressor({
                * 	"threshold" : -6,
                * 	"ratio" : 3,
                * 	"attack" : 0.5,
                * 	"release" : 0.1
                * });
                * //give a little boost to the lows
                * var lowBump = new Tone.Filter(200, "lowshelf");
                * //route everything through the filter
                * //and compressor before going to the speakers
                * Destination.chain(lowBump, masterCompressor);
                */
            chain(...args: Array<AudioNode | ToneAudioNode>): this;
            /**
                * Clean up
                */
            dispose(): this;
    }
    export {};
}

declare module 'tone/core/clock/Transport' {
    import { TimeClass } from "tone/core/type/Time";
    import { PlaybackState } from "tone/core/util/StateTimeline";
    import { Signal } from "tone/signal/Signal";
    import { ToneWithContext, ToneWithContextOptions } from "tone/core/context/ToneWithContext";
    import { TransportTimeClass } from "tone/core/type/TransportTime";
    import { BarsBeatsSixteenths, BPM, NormalRange, Seconds, Subdivision, Ticks, Time, TimeSignature, TransportTime } from "tone/core/type/Units";
    import { Emitter } from "tone/core/util/Emitter";
    import { TickParam } from "tone/core/clock/TickParam";
    interface TransportOptions extends ToneWithContextOptions {
            bpm: BPM;
            swing: NormalRange;
            swingSubdivision: Subdivision;
            timeSignature: number;
            loopStart: Time;
            loopEnd: Time;
            ppq: number;
    }
    type TransportEventNames = "start" | "stop" | "pause" | "loop" | "loopEnd" | "loopStart";
    type TransportCallback = (time: Seconds) => void;
    /**
        * Transport for timing musical events.
        * Supports tempo curves and time changes. Unlike browser-based timing (setInterval, requestAnimationFrame)
        * Transport timing events pass in the exact time of the scheduled event
        * in the argument of the callback function. Pass that time value to the object
        * you're scheduling. <br><br>
        * A single transport is created for you when the library is initialized.
        * <br><br>
        * The transport emits the events: "start", "stop", "pause", and "loop" which are
        * called with the time of that event as the argument.
        *
        * @example
        * //repeated event every 8th note
        * Transport.scheduleRepeat(function(time){
        * //do something with the time
        * }, "8n");
        * @example
        * //schedule an event on the 16th measure
        * Transport.schedule(function(time){
        * //do something with the time
        * }, "16:0:0");
        * @category Core
        */
    export class Transport extends ToneWithContext<TransportOptions> implements Emitter<TransportEventNames> {
            readonly name: string;
            /**
                * The Beats Per Minute of the Transport.
                * @example
                * Transport.bpm.value = 80;
                * //ramp the bpm to 120 over 10 seconds
                * Transport.bpm.rampTo(120, 10);
                */
            bpm: TickParam<BPM>;
            constructor(options?: Partial<TransportOptions>);
            static getDefaults(): TransportOptions;
            /**
                * Schedule an event along the timeline.
                * @param callback The callback to be invoked at the time.
                * @param time The time to invoke the callback at.
                * @return The id of the event which can be used for canceling the event.
                * @example
                * //trigger the callback when the Transport reaches the desired time
                * Transport.schedule(function(time){
                * envelope.triggerAttack(time);
                * }, "128i");
                */
            schedule(callback: TransportCallback, time: TransportTime | TransportTimeClass): number;
            /**
                * Schedule a repeated event along the timeline. The event will fire
                * at the `interval` starting at the `startTime` and for the specified
                * `duration`.
                * @param  callback   The callback to invoke.
                * @param  interval   The duration between successive callbacks. Must be a positive number.
                * @param  startTime  When along the timeline the events should start being invoked.
                * @param  duration How long the event should repeat.
                * @return  The ID of the scheduled event. Use this to cancel the event.
                * @example
                * //a callback invoked every eighth note after the first measure
                * Transport.scheduleRepeat(callback, "8n", "1m");
                */
            scheduleRepeat(callback: TransportCallback, interval: Time | TimeClass, startTime?: TransportTime | TransportTimeClass, duration?: Time): number;
            /**
                * Schedule an event that will be removed after it is invoked.
                * @param callback The callback to invoke once.
                * @param time The time the callback should be invoked.
                * @returns The ID of the scheduled event.
                */
            scheduleOnce(callback: TransportCallback, time: TransportTime | TransportTimeClass): number;
            /**
                * Clear the passed in event id from the timeline
                * @param eventId The id of the event.
                */
            clear(eventId: number): this;
            /**
                * Remove scheduled events from the timeline after
                * the given time. Repeated events will be removed
                * if their startTime is after the given time
                * @param after Clear all events after this time.
                */
            cancel(after?: TransportTime): this;
            /**
                * Returns the playback state of the source, either "started", "stopped", or "paused"
                */
            readonly state: PlaybackState;
            /**
                * Start the transport and all sources synced to the transport.
                * @param  time The time when the transport should start.
                * @param  offset The timeline offset to start the transport.
                * @example
                * //start the transport in one second starting at beginning of the 5th measure.
                * Transport.start("+1", "4:0:0");
                */
            start(time?: Time, offset?: TransportTime): this;
            /**
                * Stop the transport and all sources synced to the transport.
                * @param time The time when the transport should stop.
                * @example
                * Transport.stop();
                */
            stop(time?: Time): this;
            /**
                * Pause the transport and all sources synced to the transport.
                */
            pause(time?: Time): this;
            /**
                * Toggle the current state of the transport. If it is
                * started, it will stop it, otherwise it will start the Transport.
                * @param  time The time of the event
                */
            toggle(time?: Time): this;
            /**
                * The time signature as just the numerator over 4.
                * For example 4/4 would be just 4 and 6/8 would be 3.
                * @example
                * //common time
                * Transport.timeSignature = 4;
                * // 7/8
                * Transport.timeSignature = [7, 8];
                * //this will be reduced to a single number
                * Transport.timeSignature; //returns 3.5
                */
            timeSignature: TimeSignature;
            /**
                * When the Transport.loop = true, this is the starting position of the loop.
                */
            loopStart: Time;
            /**
                * When the Transport.loop = true, this is the ending position of the loop.
                */
            loopEnd: Time;
            /**
                * If the transport loops or not.
                */
            loop: boolean;
            /**
                * Set the loop start and stop at the same time.
                * @example
                * //loop over the first measure
                * Transport.setLoopPoints(0, "1m");
                * Transport.loop = true;
                */
            setLoopPoints(startPosition: TransportTime, endPosition: TransportTime): this;
            /**
                * The swing value. Between 0-1 where 1 equal to the note + half the subdivision.
                */
            swing: NormalRange;
            /**
                * Set the subdivision which the swing will be applied to.
                * The default value is an 8th note. Value must be less
                * than a quarter note.
                */
            swingSubdivision: Subdivision;
            /**
                * The Transport's position in Bars:Beats:Sixteenths.
                * Setting the value will jump to that position right away.
                */
            position: BarsBeatsSixteenths | Time;
            /**
                * The Transport's position in seconds
                * Setting the value will jump to that position right away.
                */
            seconds: Seconds;
            /**
                * The Transport's loop position as a normalized value. Always
                * returns 0 if the transport if loop is not true.
                */
            readonly progress: NormalRange;
            /**
                * The transports current tick position.
                */
            ticks: Ticks;
            /**
                * Get the clock's ticks at the given time.
                * @param  time  When to get the tick value
                * @return The tick value at the given time.
                */
            getTicksAtTime(time?: Time): Ticks;
            /**
                * Return the elapsed seconds at the given time.
                * @param  time  When to get the elapsed seconds
                * @return  The number of elapsed seconds
                */
            getSecondsAtTime(time: Time): Seconds;
            /**
                * Pulses Per Quarter note. This is the smallest resolution
                * the Transport timing supports. This should be set once
                * on initialization and not set again. Changing this value
                * after other objects have been created can cause problems.
                */
            PPQ: number;
            /**
                * Returns the time aligned to the next subdivision
                * of the Transport. If the Transport is not started,
                * it will return 0.
                * Note: this will not work precisely during tempo ramps.
                * @param  subdivision  The subdivision to quantize to
                * @return  The context time of the next subdivision.
                * @example
                * Transport.start(); //the transport must be started
                * Transport.nextSubdivision("4n");
                */
            nextSubdivision(subdivision?: Time): Seconds;
            /**
                * Attaches the signal to the tempo control signal so that
                * any changes in the tempo will change the signal in the same
                * ratio.
                *
                * @param signal
                * @param ratio Optionally pass in the ratio between the two signals.
                * 			Otherwise it will be computed based on their current values.
                */
            syncSignal(signal: Signal<any>, ratio?: number): this;
            /**
                * Unsyncs a previously synced signal from the transport's control.
                * See Transport.syncSignal.
                */
            unsyncSignal(signal: Signal<any>): this;
            /**
                * Clean up.
                */
            dispose(): this;
            on: (event: TransportEventNames, callback: (...args: any[]) => void) => this;
            once: (event: TransportEventNames, callback: (...args: any[]) => void) => this;
            off: (event: TransportEventNames, callback?: ((...args: any[]) => void) | undefined) => this;
            emit: (event: any, ...args: any[]) => this;
    }
    export {};
}

declare module 'tone/core/type/Conversions' {
    import { Decibels, GainFactor, Hertz, Interval, MidiNote, NormalRange } from "tone/core/type/Units";
    /**
        * Equal power gain scale. Good for cross-fading.
        * @param  percent (0-1)
        */
    export function equalPowerScale(percent: NormalRange): number;
    /**
        * Convert decibels into gain.
        */
    export function dbToGain(db: Decibels): GainFactor;
    /**
        * Convert gain to decibels.
        */
    export function gainToDb(gain: GainFactor): Decibels;
    /**
        * Convert an interval (in semitones) to a frequency ratio.
        * @param interval the number of semitones above the base note
        * @example
        * tone.intervalToFrequencyRatio(0); // 1
        * tone.intervalToFrequencyRatio(12); // 2
        * tone.intervalToFrequencyRatio(-12); // 0.5
        */
    export function intervalToFrequencyRatio(interval: Interval): number;
    export function getA4(): Hertz;
    export function setA4(freq: Hertz): void;
    /**
        * Convert a frequency value to a MIDI note.
        * @param frequency The value to frequency value to convert.
        * @example
        * ftom(440); // returns 69
        */
    export function ftom(frequency: Hertz): MidiNote;
    /**
        * Convert a frequency to a floating point midi value
        */
    export function ftomf(frequency: Hertz): number;
    /**
        * Convert a MIDI note to frequency value.
        * @param  midi The midi number to convert.
        * @return The corresponding frequency value
        * @example
        */
    export function mtof(midi: MidiNote): Hertz;
}

declare module 'tone/core/util/Defaults' {
    type BaseToneOptions = import("../Tone").BaseToneOptions;
    /**
        * Recursively merge an object
        * @param target the object to merge into
        * @param sources the source objects to merge
        */
    export function deepMerge<T>(target: T): T;
    export function deepMerge<T, U>(target: T, source1: U): T & U;
    export function deepMerge<T, U, V>(target: T, source1: U, source2: V): T & U & V;
    export function deepMerge<T, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W;
    /**
        * Returns true if the two arrays have the same value for each of the elements
        */
    export function deepEquals(arrayA: number[] | string[], arrayB: number[] | string[]): boolean;
    /**
        * Convert an args array into an object.
        */
    export function optionsFromArguments<T extends object>(defaults: T, argsArray: IArguments, keys?: string[], objKey?: string): T;
    /**
        * Return this instances default values by calling Constructor.getDefaults()
        */
    export function getDefaultsFromInstance<T>(instance: T): BaseToneOptions;
    /**
        * Returns the fallback if the given object is undefined.
        * Take an array of arguments and return a formatted options object.
        */
    export function defaultArg<T>(given: T, fallback: T): T;
    /**
        * Remove all of the properties belonging to omit from obj.
        */
    export function omitFromObject<T extends object, O extends string[]>(obj: T, omit: O): Omit<T, keyof O>;
    export {};
}

declare module 'tone/core/Connect' {
    export { connect, disconnect, connectSeries } from "tone/core/context/ToneAudioNode";
}

declare module 'tone/core/util/TypeCheck' {
    import { Note } from "tone/core/type/Units";
    /**
        * Test if the arg is undefined
        */
    export function isUndef(arg: any): arg is undefined;
    /**
        * Test if the arg is not undefined
        */
    export function isDefined<T>(arg: T | undefined): arg is T;
    /**
        * Test if the arg is a function
        */
    export function isFunction(arg: any): arg is (a: any) => any;
    /**
        * Test if the argument is a number.
        */
    export function isNumber(arg: any): arg is number;
    /**
        * Test if the given argument is an object literal (i.e. `{}`);
        */
    export function isObject(arg: any): arg is object;
    /**
        * Test if the argument is a boolean.
        */
    export function isBoolean(arg: any): arg is boolean;
    /**
        * Test if the argument is an Array
        */
    export function isArray(arg: any): arg is any[];
    /**
        * Test if the argument is a string.
        */
    export function isString(arg: any): arg is string;
    /**
        * Test if the argument is in the form of a note in scientific pitch notation.
        * e.g. "C4"
        */
    export function isNote(arg: any): arg is Note;
}

declare module 'tone/core/util/Debug' {
    /**
        * Assert that the statement is true, otherwise invoke an error with the given message.
        */
    export function assert(statement: boolean, error: string): void;
    /**
        * Make sure that the given value is within the range
        */
    export function assertRange(value: number, gte: number, lte?: number): void;
    /**
        * A basic logging interface
        */
    interface Logger {
            log: (args?: any[]) => void;
            warn: (args?: any[]) => void;
    }
    /**
        * Set the logging interface
        */
    export function setLogger(logger: Logger): void;
    /**
        * Log anything
        */
    export function log(...args: any[]): void;
    /**
        * Warn anything
        */
    export function warn(...args: any[]): void;
    export {};
}

declare module 'tone/source/Noise' {
    import { Positive, Time } from "tone/core/type/Units";
    import { Source, SourceOptions } from "tone/source/Source";
    export type NoiseType = "white" | "brown" | "pink";
    export interface NoiseOptions extends SourceOptions {
            type: NoiseType;
            playbackRate: Positive;
            fadeIn: Time;
            fadeOut: Time;
    }
    /**
        * Noise is a noise generator. It uses looped noise buffers to save on performance.
        * Noise supports the noise types: "pink", "white", and "brown". Read more about
        * colors of noise on [Wikipedia](https://en.wikipedia.org/wiki/Colors_of_noise).
        *
        * @example
        * //initialize the noise and start
        * var noise = new Noise("pink").start();
        *
        * //make an autofilter to shape the noise
        * var autoFilter = new Tone.AutoFilter({
        * 	"frequency" : "8m",
        * 	"min" : 800,
        * 	"max" : 15000
        * }).connect(Tone.Destination);
        *
        * //connect the noise
        * noise.connect(autoFilter);
        * //start the autofilter LFO
        * autoFilter.start()
        * @category Source
        */
    export class Noise extends Source<NoiseOptions> {
            readonly name: string;
            /**
                * The fadeIn time of the amplitude envelope.
                */
            protected _fadeIn: Time;
            /**
                * The fadeOut time of the amplitude envelope.
                */
            protected _fadeOut: Time;
            /**
                * @param type the noise type (white|pink|brown)
                */
            constructor(type?: NoiseType);
            constructor(options?: Partial<NoiseOptions>);
            static getDefaults(): NoiseOptions;
            /**
                * The type of the noise. Can be "white", "brown", or "pink".
                * @example
                * noise.type = "white";
                */
            type: NoiseType;
            /**
                * The playback rate of the noise. Affects
                * the "frequency" of the noise.
                */
            playbackRate: Positive;
            /**
                * internal start method
                */
            protected _start(time?: Time): void;
            /**
                * internal stop method
                */
            protected _stop(time?: Time): void;
            /**
                * The fadeIn time of the amplitude envelope.
                */
            fadeIn: Time;
            /**
                * The fadeOut time of the amplitude envelope.
                */
            fadeOut: Time;
            /**
                * Restarts the noise.
                * @param  time When to restart the noise.
                */
            restart(time?: Time): this;
            /**
                * Clean up.
                */
            dispose(): this;
    }
}

declare module 'tone/source/UserMedia' {
    import { OutputNode, ToneAudioNode, ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    import { Decibels } from "tone/core/type/Units";
    import { Param } from "tone/core/context/Param";
    export interface UserMediaOptions extends ToneAudioNodeOptions {
            volume: Decibels;
            mute: boolean;
    }
    /**
        * UserMedia uses MediaDevices.getUserMedia to open up and external microphone or audio input.
        * Check [MediaDevices API Support](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia)
        * to see which browsers are supported. Access to an external input
        * is limited to secure (HTTPS) connections.
        *
        * @example
        * //list the inputs and open the third one
        * const motu = new UserMedia();
        * motu.open().then(() => {
        * 	//promise resolves when input is available
        * });
        * @category Source
        */
    export class UserMedia extends ToneAudioNode<UserMediaOptions> {
            readonly name: string;
            readonly input: undefined;
            readonly output: OutputNode;
            /**
                * The volume of the output in decibels.
                * @example
                * input.volume.value = -6;
                */
            readonly volume: Param<Decibels>;
            /**
                * @param volume The level of the input in decibels
                */
            constructor(volume?: Decibels);
            constructor(options?: Partial<UserMediaOptions>);
            static getDefaults(): UserMediaOptions;
            /**
                * Open the media stream. If a string is passed in, it is assumed
                * to be the label or id of the stream, if a number is passed in,
                * it is the input number of the stream.
                * @param  labelOrId The label or id of the audio input media device.
                *                   With no argument, the default stream is opened.
                * @return The promise is resolved when the stream is open.
                */
            open(labelOrId?: string | number): Promise<void>;
            /**
                * Close the media stream
                */
            close(): this;
            /**
                * Returns a promise which resolves with the list of audio input devices available.
                * @return The promise that is resolved with the devices
                * @example
                * UserMedia.enumerateDevices().then((devices) => {
                * 	console.log(devices)
                * })
                */
            static enumerateDevices(): Promise<MediaDeviceInfo[]>;
            /**
                * Returns the playback state of the source, "started" when the microphone is open
                * and "stopped" when the mic is closed.
                */
            readonly state: "started" | "stopped";
            /**
                * Returns an identifier for the represented device that is
                * persisted across sessions. It is un-guessable by other applications and
                * unique to the origin of the calling application. It is reset when the
                * user clears cookies (for Private Browsing, a different identifier is
                * used that is not persisted across sessions). Returns undefined when the
                * device is not open.
                */
            readonly deviceId: string | undefined;
            /**
                * Returns a group identifier. Two devices have the
                * same group identifier if they belong to the same physical device.
                * Returns null  when the device is not open.
                */
            readonly groupId: string | undefined;
            /**
                * Returns a label describing this device (for example "Built-in Microphone").
                * Returns undefined when the device is not open or label is not available
                * because of permissions.
                */
            readonly label: string | undefined;
            /**
                * Mute the output.
                * @example
                * //mute the output
                * userMedia.mute = true;
                */
            mute: boolean;
            dispose(): this;
            /**
                * If getUserMedia is supported by the browser.
                */
            static readonly supported: boolean;
    }
}

declare module 'tone/source/oscillator/Oscillator' {
    import { AudioRange, Cents, Degrees, Frequency, Time } from "tone/core/type/Units";
    import { Signal } from "tone/signal/Signal";
    import { Source } from "tone/source/Source";
    import { ToneOscillatorConstructorOptions, ToneOscillatorInterface, ToneOscillatorOptions, ToneOscillatorType } from "tone/source/oscillator/OscillatorInterface";
    export { ToneOscillatorOptions, ToneOscillatorType } from "tone/source/oscillator/OscillatorInterface";
    /**
        * Oscillator supports a number of features including
        * phase rotation, multiple oscillator types (see Oscillator.type),
        * and Transport syncing (see Oscillator.syncFrequency).
        *
        * @example
        * //make and start a 440hz sine tone
        * var osc = new Oscillator(440, "sine").toDestination().start();
        * @category Source
        */
    export class Oscillator extends Source<ToneOscillatorOptions> implements ToneOscillatorInterface {
            readonly name: string;
            /**
                * The frequency control.
                */
            frequency: Signal<Frequency>;
            /**
                * The detune control signal.
                */
            detune: Signal<Cents>;
            /**
                * @param frequency Starting frequency
                * @param type The oscillator type. Read more about type below.
                */
            constructor(frequency?: Frequency, type?: ToneOscillatorType);
            constructor(options?: Partial<ToneOscillatorConstructorOptions>);
            static getDefaults(): ToneOscillatorOptions;
            /**
                * start the oscillator
                */
            protected _start(time?: Time): void;
            /**
                * stop the oscillator
                */
            protected _stop(time?: Time): void;
            /**
                * Restart the oscillator. Does not stop the oscillator, but instead
                * just cancels any scheduled 'stop' from being invoked.
                */
            restart(time?: Time): this;
            /**
                * Sync the signal to the Transport's bpm. Any changes to the transports bpm,
                * will also affect the oscillators frequency.
                * @example
                * Tone.Transport.bpm.value = 120;
                * osc.frequency.value = 440;
                * //the ration between the bpm and the frequency will be maintained
                * osc.syncFrequency();
                * Tone.Transport.bpm.value = 240;
                * // the frequency of the oscillator is doubled to 880
                */
            syncFrequency(): this;
            /**
                * Unsync the oscillator's frequency from the Transport.
                * See Oscillator.syncFrequency
                */
            unsyncFrequency(): this;
            /**
                * The type of the oscillator: either sine, square, triangle, or sawtooth. Also capable of
                * setting the first x number of partials of the oscillator. For example: "sine4" would
                * set be the first 4 partials of the sine wave and "triangle8" would set the first
                * 8 partials of the triangle wave.
                * <br><br>
                * Uses PeriodicWave internally even for native types so that it can set the phase.
                * PeriodicWave equations are from the
                * [Webkit Web Audio implementation](https://code.google.com/p/chromium/codesearch#chromium/src/third_party/WebKit/Source/modules/webaudio/PeriodicWave.cpp&sq=package:chromium).
                *
                * @memberOf Oscillator#
                * @type {string}
                * @name type
                * @example
                * //set it to a square wave
                * osc.type = "square";
                * @example
                * //set the first 6 partials of a sawtooth wave
                * osc.type = "sawtooth6";
                */
            type: ToneOscillatorType;
            /**
                * The oscillator type without the partialsCount appended to the end
                * @example
                * osc.type = 'sine2'
                * osc.baseType //'sine'
                * osc.partialCount = 2
                */
            baseType: OscillatorType;
            /**
                * 'partialCount' offers an alternative way to set the number of used partials.
                * When partialCount is 0, the maximum number of partials are used when representing
                * the waveform using the periodicWave. When 'partials' is set, this value is
                * not settable, but equals the length of the partials array.
                * @example
                * osc.type = 'sine'
                * osc.partialCount = 3
                * //is equivalent to
                * osc.type = 'sine3'
                */
            partialCount: number;
            /**
                * Returns the initial value of the oscillator when stopped.
                * E.g. a "sine" oscillator with phase = 90 would return an initial value of -1.
                */
            getInitialValue(): AudioRange;
            /**
                * The partials of the waveform. A partial represents
                * the amplitude at a harmonic. The first harmonic is the
                * fundamental frequency, the second is the octave and so on
                * following the harmonic series.
                * Setting this value will automatically set the type to "custom".
                * The value is an empty array when the type is not "custom".
                * @example
                * osc.partials = [1, 0.2, 0.01];
                */
            partials: number[];
            /**
                * The phase of the oscillator in degrees.
                * @example
                * osc.phase = 180; //flips the phase of the oscillator
                */
            phase: Degrees;
            asArray(length?: number): Promise<Float32Array>;
            dispose(): this;
    }
}

declare module 'tone/source/oscillator/AMOscillator' {
    import { Cents, Degrees, Frequency, Positive, Seconds, Time } from "tone/core/type/Units";
    import { Signal } from "tone/signal/Signal";
    import { Source } from "tone/source/Source";
    import { AMConstructorOptions, AMOscillatorOptions, ToneOscillatorInterface, ToneOscillatorType } from "tone/source/oscillator/OscillatorInterface";
    export { AMOscillatorOptions } from "tone/source/oscillator/OscillatorInterface";
    /**
        * An amplitude modulated oscillator node. It is implemented with
        * two oscillators, one which modulators the other's amplitude
        * through a gain node.
        * ```
        *    +-------------+       +----------+
        *    | Carrier Osc +>------> GainNode |
        *    +-------------+       |          +--->Output
        *                      +---> gain     |
        * +---------------+    |   +----------+
        * | Modulator Osc +>---+
        * +---------------+
        * ```
        *
        * @example
        * // a sine oscillator amplitude-modulated by a square wave
        * const amOsc = new AMOscillator("Ab3", "sine", "square").toDestination().start();
        * @category Source
        */
    export class AMOscillator extends Source<AMOscillatorOptions> implements ToneOscillatorInterface {
            readonly name: string;
            /**
                * The oscillator's frequency
                */
            readonly frequency: Signal<Frequency>;
            /**
                * The detune control signal.
                */
            readonly detune: Signal<Cents>;
            /**
                * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.
                * A harmonicity of 1 gives both oscillators the same frequency.
                * Harmonicity = 2 means a change of an octave.
                * @example
                * //pitch the modulator an octave below carrier
                * synth.harmonicity.value = 0.5;
                */
            readonly harmonicity: Signal<Positive>;
            /**
                * @param frequency The starting frequency of the oscillator.
                * @param type The type of the carrier oscillator.
                * @param modulationType The type of the modulator oscillator.
                */
            constructor(frequency?: Frequency, type?: ToneOscillatorType, modulationType?: ToneOscillatorType);
            constructor(options?: Partial<AMConstructorOptions>);
            static getDefaults(): AMOscillatorOptions;
            /**
                * start the oscillator
                */
            protected _start(time: Seconds): void;
            /**
                * stop the oscillator
                */
            protected _stop(time: Seconds): void;
            /**
                * restart the oscillator
                */
            restart(time?: Time): this;
            /**
                * The type of the carrier oscillator
                */
            type: ToneOscillatorType;
            /**
                * The oscillator type without the partialsCount appended to the end
                * @example
                * osc.type = 'sine2'
                * osc.baseType //'sine'
                * osc.partialCount = 2
                */
            baseType: OscillatorType;
            /**
                * 'partialCount' offers an alternative way to set the number of used partials.
                * When partialCount is 0, the maximum number of partials are used when representing
                * the waveform using the periodicWave. When 'partials' is set, this value is
                * not settable, but equals the length of the partials array.
                */
            partialCount: number;
            /**
                * The type of the modulator oscillator
                */
            modulationType: ToneOscillatorType;
            /**
                * The phase of the oscillator in degrees.
                */
            phase: Degrees;
            /**
                * The partials of the carrier waveform. A partial represents
                * the amplitude at a harmonic. The first harmonic is the
                * fundamental frequency, the second is the octave and so on
                * following the harmonic series.
                * Setting this value will automatically set the type to "custom".
                * The value is an empty array when the type is not "custom".
                * @example
                * osc.partials = [1, 0.2, 0.01];
                */
            partials: number[];
            asArray(length?: number): Promise<Float32Array>;
            /**
                * Clean up.
                */
            dispose(): this;
    }
}

declare module 'tone/source/oscillator/FMOscillator' {
    import { Cents, Degrees, Frequency, Positive, Time } from "tone/core/type/Units";
    import { Signal } from "tone/signal/Signal";
    import { Source } from "tone/source/Source";
    import { FMConstructorOptions, FMOscillatorOptions, ToneOscillatorInterface, ToneOscillatorType } from "tone/source/oscillator/OscillatorInterface";
    export { FMOscillatorOptions } from "tone/source/oscillator/OscillatorInterface";
    /**
        * FMOscillator implements a frequency modulation synthesis
        * ```
        *                                              +-------------+
        * +---------------+        +-------------+     | Carrier Osc |
        * | Modulator Osc +>-------> GainNode    |     |             +--->Output
        * +---------------+        |             +>----> frequency   |
        *                       +--> gain        |     +-------------+
        *                       |  +-------------+
        * +-----------------+   |
        * | modulationIndex +>--+
        * +-----------------+
        * ```
        *
        * @example
        * //a sine oscillator frequency-modulated by a square wave
        * var fmOsc = new FMOscillator("Ab3", "sine", "square").toDestination().start();
        * @category Source
        */
    export class FMOscillator extends Source<FMOscillatorOptions> implements ToneOscillatorInterface {
            readonly name: string;
            /**
                * The oscillator's frequency
                */
            readonly frequency: Signal<Frequency>;
            /**
                * The detune control signal.
                */
            readonly detune: Signal<Cents>;
            /**
                * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.
                * A harmonicity of 1 gives both oscillators the same frequency.
                * Harmonicity = 2 means a change of an octave.
                * @example
                * //pitch the modulator an octave below carrier
                * synth.harmonicity.value = 0.5;
                */
            readonly harmonicity: Signal<Positive>;
            /**
                * The modulation index which is in essence the depth or amount of the modulation. In other terms it is the
                * ratio of the frequency of the modulating signal (mf) to the amplitude of the
                * modulating signal (ma) -- as in ma/mf.
                */
            readonly modulationIndex: Signal<Positive>;
            /**
                * @param frequency The starting frequency of the oscillator.
                * @param type The type of the carrier oscillator.
                * @param modulationType The type of the modulator oscillator.
                */
            constructor(frequency?: Frequency, type?: ToneOscillatorType, modulationType?: ToneOscillatorType);
            constructor(options?: Partial<FMConstructorOptions>);
            static getDefaults(): FMOscillatorOptions;
            /**
                * start the oscillator
                */
            protected _start(time: Time): void;
            /**
                * stop the oscillator
                */
            protected _stop(time: Time): void;
            /**
                * stop and restart the oscillator
                */
            restart(time?: Time): this;
            /**
                * The type of the carrier oscillator
                */
            type: ToneOscillatorType;
            /**
                * The oscillator type without the partialsCount appended to the end
                * @example
                * osc.type = 'sine2'
                * osc.baseType //'sine'
                * osc.partialCount = 2
                */
            baseType: OscillatorType;
            /**
                * 'partialCount' offers an alternative way to set the number of used partials.
                * When partialCount is 0, the maximum number of partials are used when representing
                * the waveform using the periodicWave. When 'partials' is set, this value is
                * not settable, but equals the length of the partials array.
                */
            partialCount: number;
            /**
                * The type of the modulator oscillator
                */
            modulationType: ToneOscillatorType;
            /**
                * The phase of the oscillator in degrees.
                */
            phase: Degrees;
            /**
                * The partials of the carrier waveform. A partial represents
                * the amplitude at a harmonic. The first harmonic is the
                * fundamental frequency, the second is the octave and so on
                * following the harmonic series.
                * Setting this value will automatically set the type to "custom".
                * The value is an empty array when the type is not "custom".
                * @example
                * osc.partials = [1, 0.2, 0.01];
                */
            partials: number[];
            asArray(length?: number): Promise<Float32Array>;
            /**
                * Clean up.
                */
            dispose(): this;
    }
}

declare module 'tone/source/oscillator/PulseOscillator' {
    import { AudioRange, Cents, Degrees, Frequency, Time } from "tone/core/type/Units";
    import { Signal } from "tone/signal/Signal";
    import { Source } from "tone/source/Source";
    import { PulseOscillatorOptions, ToneOscillatorInterface } from "tone/source/oscillator/OscillatorInterface";
    export { PulseOscillatorOptions } from "tone/source/oscillator/OscillatorInterface";
    /**
        * PulseOscillator is an oscillator with control over pulse width,
        * also known as the duty cycle. At 50% duty cycle (width = 0) the wave is
        * a square wave.
        * [Read more](https://wigglewave.wordpress.com/2014/08/16/pulse-waveforms-and-harmonics/).
        * ```
        *    width = -0.25        width = 0.0          width = 0.25
        *
        *   +-----+            +-------+       +    +-------+     +-+
        *   |     |            |       |       |            |     |
        *   |     |            |       |       |            |     |
        * +-+     +-------+    +       +-------+            +-----+
        *
        *
        *    width = -0.5                              width = 0.5
        *
        *     +---+                                 +-------+   +---+
        *     |   |                                         |   |
        *     |   |                                         |   |
        * +---+   +-------+                                 +---+
        *
        *
        *    width = -0.75                             width = 0.75
        *
        *       +-+                                 +-------+ +-----+
        *       | |                                         | |
        *       | |                                         | |
        * +-----+ +-------+                                 +-+
        * ```
        * @example
        * const pulse = new PulseOscillator("E5", 0.4).toDestination().start();
        * @category Source
        */
    export class PulseOscillator extends Source<PulseOscillatorOptions> implements ToneOscillatorInterface {
            readonly name: string;
            /**
                * The width of the pulse.
                */
            width: Signal<AudioRange>;
            /**
                * The frequency control.
                */
            frequency: Signal<Frequency>;
            /**
                * The detune in cents.
                */
            detune: Signal<Cents>;
            /**
                * @param frequency The frequency of the oscillator
                * @param width The width of the pulse
                */
            constructor(frequency?: Frequency, width?: AudioRange);
            constructor(options?: Partial<PulseOscillatorOptions>);
            static getDefaults(): PulseOscillatorOptions;
            /**
                * start the oscillator
                */
            protected _start(time: Time): void;
            /**
                * stop the oscillator
                */
            protected _stop(time: Time): void;
            /**
                * Restart the oscillator
                */
            restart(time?: Time): this;
            /**
                * The phase of the oscillator in degrees.
                */
            phase: Degrees;
            /**
                * The type of the oscillator. Always returns "pulse".
                */
            readonly type: "pulse";
            /**
                * The baseType of the oscillator. Always returns "pulse".
                */
            readonly baseType: "pulse";
            /**
                * The partials of the waveform. Cannot set partials for this waveform type
                */
            readonly partials: number[];
            /**
                * No partials for this waveform type.
                */
            readonly partialCount: number;
            asArray(length?: number): Promise<Float32Array>;
            /**
                * Clean up method.
                */
            dispose(): this;
    }
}

declare module 'tone/source/oscillator/FatOscillator' {
    import { Cents, Degrees, Frequency, Time } from "tone/core/type/Units";
    import { Signal } from "tone/signal/Signal";
    import { Source } from "tone/source/Source";
    import { FatConstructorOptions, FatOscillatorOptions, ToneOscillatorInterface, ToneOscillatorType } from "tone/source/oscillator/OscillatorInterface";
    export { FatOscillatorOptions } from "tone/source/oscillator/OscillatorInterface";
    /**
        * FatOscillator is an array of oscillators with detune spread between the oscillators
        * @param frequency The oscillator's frequency.
        * @param type The type of the oscillator.
        * @param spread The detune spread between the oscillators.
        * @example
        * var fatOsc = new FatOscillator("Ab3", "sine", 40).toDestination().start();
        * @category Source
        */
    export class FatOscillator extends Source<FatOscillatorOptions> implements ToneOscillatorInterface {
            readonly name: string;
            /**
                * The oscillator's frequency
                */
            readonly frequency: Signal<Frequency>;
            /**
                * The detune control signal.
                */
            readonly detune: Signal<Cents>;
            constructor(options?: Partial<FatConstructorOptions>);
            constructor(frequency?: Frequency, type?: ToneOscillatorType, modulationType?: ToneOscillatorType);
            static getDefaults(): FatOscillatorOptions;
            /**
                * start the oscillator
                */
            protected _start(time: Time): void;
            /**
                * stop the oscillator
                */
            protected _stop(time: Time): void;
            /**
                * restart the oscillator
                */
            restart(time: any): this;
            /**
                * The type of the oscillator
                */
            type: ToneOscillatorType;
            /**
                * The detune spread between the oscillators. If "count" is
                * set to 3 oscillators and the "spread" is set to 40,
                * the three oscillators would be detuned like this: [-20, 0, 20]
                * for a total detune spread of 40 cents.
                */
            spread: Cents;
            /**
                * The number of detuned oscillators. Should be an integer greater than 1.
                */
            count: number;
            /**
                * The phase of the oscillator in degrees.
                */
            phase: Degrees;
            /**
                * The oscillator type without the partialsCount appended to the end
                * @example
                * osc.type = 'sine2'
                * osc.baseType //'sine'
                * osc.partialCount = 2
                */
            baseType: OscillatorType;
            /**
                * The partials of the carrier waveform. A partial represents
                * the amplitude at a harmonic. The first harmonic is the
                * fundamental frequency, the second is the octave and so on
                * following the harmonic series.
                * Setting this value will automatically set the type to "custom".
                * The value is an empty array when the type is not "custom".
                * @memberOf FatOscillator#
                * @type {Array}
                * @name partials
                * @example
                * osc.partials = [1, 0.2, 0.01];
                */
            partials: number[];
            /**
                * 'partialCount' offers an alternative way to set the number of used partials.
                * When partialCount is 0, the maximum number of partials are used when representing
                * the waveform using the periodicWave. When 'partials' is set, this value is
                * not settable, but equals the length of the partials array.
                * @memberOf FatOscillator#
                * @type {Number}
                * @name partialCount
                */
            partialCount: number;
            asArray(length?: number): Promise<Float32Array>;
            /**
                * Clean up.
                */
            dispose(): this;
    }
}

declare module 'tone/source/oscillator/PWMOscillator' {
    import { Cents, Degrees, Frequency, Time } from "tone/core/type/Units";
    import { Signal } from "tone/signal/Signal";
    import { Source } from "tone/source/Source";
    import { PWMOscillatorOptions, ToneOscillatorInterface } from "tone/source/oscillator/OscillatorInterface";
    export { PWMOscillatorOptions } from "tone/source/oscillator/OscillatorInterface";
    /**
        * PWMOscillator modulates the width of a Tone.PulseOscillator
        * at the modulationFrequency. This has the effect of continuously
        * changing the timbre of the oscillator by altering the harmonics
        * generated.
        * @example
        * var pwm = new PWMOscillator("Ab3", 0.3).toDestination().start();
        * @category Source
        */
    export class PWMOscillator extends Source<PWMOscillatorOptions> implements ToneOscillatorInterface {
            readonly name: string;
            readonly sourceType = "pwm";
            /**
                * The frequency control.
                */
            readonly frequency: Signal<Frequency>;
            /**
                * The detune of the oscillator.
                */
            readonly detune: Signal<Cents>;
            /**
                * The modulation rate of the oscillator.
                */
            readonly modulationFrequency: Signal<Frequency>;
            /**
                * @param {Frequency} frequency The starting frequency of the oscillator.
                * @param {Frequency} modulationFrequency The modulation frequency of the width of the pulse.
                */
            constructor(frequency?: Frequency, modulationFrequency?: Frequency);
            constructor(options?: Partial<PWMOscillatorOptions>);
            static getDefaults(): PWMOscillatorOptions;
            /**
                * start the oscillator
                */
            protected _start(time: Time): void;
            /**
                * stop the oscillator
                */
            protected _stop(time: Time): void;
            /**
                * restart the oscillator
                */
            restart(time?: Time): this;
            /**
                * The type of the oscillator. Always returns "pwm".
                */
            readonly type: "pwm";
            /**
                * The baseType of the oscillator. Always returns "pwm".
                */
            readonly baseType: "pwm";
            /**
                * The partials of the waveform. Cannot set partials for this waveform type
                */
            readonly partials: number[];
            /**
                * No partials for this waveform type.
                */
            readonly partialCount: number;
            /**
                * The phase of the oscillator in degrees.
                */
            phase: Degrees;
            asArray(length?: number): Promise<Float32Array>;
            /**
                * Clean up.
                */
            dispose(): this;
    }
}

declare module 'tone/source/oscillator/OmniOscillator' {
    import { AudioRange, Cents, Degrees, Frequency, Positive, Time } from "tone/core/type/Units";
    import { Signal } from "tone/signal/Signal";
    import { Source } from "tone/source/Source";
    import { AMOscillator } from "tone/source/oscillator/AMOscillator";
    import { FatOscillator } from "tone/source/oscillator/FatOscillator";
    import { FMOscillator } from "tone/source/oscillator/FMOscillator";
    import { Oscillator } from "tone/source/oscillator/Oscillator";
    import { OmniOscillatorConstructorOptions, OmniOscillatorOptions, OmniOscillatorType, ToneOscillatorInterface, ToneOscillatorType } from "tone/source/oscillator/OscillatorInterface";
    import { PulseOscillator } from "tone/source/oscillator/PulseOscillator";
    import { PWMOscillator } from "tone/source/oscillator/PWMOscillator";
    export { OmniOscillatorOptions } from "tone/source/oscillator/OscillatorInterface";
    /**
        * All of the oscillator types that OmniOscillator can take on
        */
    type AnyOscillator = Oscillator | PWMOscillator | PulseOscillator | FatOscillator | AMOscillator | FMOscillator;
    /**
        * All of the Oscillator constructor types mapped to their name.
        */
    interface OmniOscillatorSource {
            "fm": FMOscillator;
            "am": AMOscillator;
            "pwm": PWMOscillator;
            "pulse": PulseOscillator;
            "oscillator": Oscillator;
            "fat": FatOscillator;
    }
    /**
        * The available oscillator types.
        */
    export type OmniOscSourceType = keyof OmniOscillatorSource;
    type IsAmOrFmOscillator<Osc, Ret> = Osc extends AMOscillator ? Ret : Osc extends FMOscillator ? Ret : undefined;
    type IsFatOscillator<Osc, Ret> = Osc extends FatOscillator ? Ret : undefined;
    type IsPWMOscillator<Osc, Ret> = Osc extends PWMOscillator ? Ret : undefined;
    type IsPulseOscillator<Osc, Ret> = Osc extends PulseOscillator ? Ret : undefined;
    type IsFMOscillator<Osc, Ret> = Osc extends FMOscillator ? Ret : undefined;
    /**
        * OmniOscillator aggregates Tone.Oscillator, Tone.PulseOscillator,
        * Tone.PWMOscillator, Tone.FMOscillator, Tone.AMOscillator, and Tone.FatOscillator
        * into one class. The oscillator class can be changed by setting the `type`.
        * `omniOsc.type = "pwm"` will set it to the Tone.PWMOscillator. Prefixing
        * any of the basic types ("sine", "square4", etc.) with "fm", "am", or "fat"
        * will use the FMOscillator, AMOscillator or FatOscillator respectively.
        * For example: `omniOsc.type = "fatsawtooth"` will create set the oscillator
        * to a FatOscillator of type "sawtooth".
        * @example
        * var omniOsc = new OmniOscillator("C#4", "pwm");
        * @category Source
        */
    export class OmniOscillator<OscType extends AnyOscillator> extends Source<OmniOscillatorConstructorOptions> implements Omit<ToneOscillatorInterface, "type"> {
            readonly name: string;
            /**
                * The frequency control.
                */
            readonly frequency: Signal<Frequency>;
            /**
                * The detune control.
                */
            readonly detune: Signal<Cents>;
            /**
                * @param frequency The initial frequency of the oscillator.
                * @param type The type of the oscillator.
                */
            constructor(frequency?: Frequency, type?: OmniOscillatorType);
            constructor(options?: Partial<OmniOscillatorConstructorOptions>);
            static getDefaults(): OmniOscillatorOptions;
            /**
                * start the oscillator
                */
            protected _start(time: Time): void;
            /**
                * start the oscillator
                */
            protected _stop(time: Time): void;
            restart(time?: Time): this;
            /**
                * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or
                * prefix the basic types with "fm", "am", or "fat" to use the FMOscillator, AMOscillator or FatOscillator
                * types. The oscillator could also be set to "pwm" or "pulse". All of the parameters of the
                * oscillator's class are accessible when the oscillator is set to that type, but throws an error
                * when it's not.
                * @example
                * omniOsc.type = "pwm";
                * //modulationFrequency is parameter which is available
                * //only when the type is "pwm".
                * omniOsc.modulationFrequency.value = 0.5;
                * @example
                * //an square wave frequency modulated by a sawtooth
                * omniOsc.type = "fmsquare";
                * omniOsc.modulationType = "sawtooth";
                */
            type: OmniOscillatorType;
            /**
                * The partials of the waveform. A partial represents
                * the amplitude at a harmonic. The first harmonic is the
                * fundamental frequency, the second is the octave and so on
                * following the harmonic series.
                * Setting this value will automatically set the type to "custom".
                * The value is an empty array when the type is not "custom".
                * This is not available on "pwm" and "pulse" oscillator types.
                * @example
                * osc.partials = [1, 0.2, 0.01];
                */
            partials: number[];
            /**
                * The partial count of the oscillator. This is not available on "pwm" and "pulse" oscillator types.
                * @example
                * //set the maximum number of partials
                * osc.partialCount = 0;
                */
            partialCount: number;
            /**
                * Set the parameters at once. Either pass in an
                * object mapping parameters to values, or to set a
                * single parameter, by passing in a string and value.
                * The last argument is an optional ramp time which
                * will ramp any signal values to their destination value
                * over the duration of the rampTime.
                * @param  props
                * @example
                * //set values using an object
                * filter.set({
                * 	"frequency" : 300,
                * 	"type" : "highpass"
                * });
                */
            set(props: Partial<OmniOscillatorConstructorOptions>): this;
            /**
                * The phase of the oscillator in degrees.
                */
            phase: Degrees;
            /**
                * The source type of the oscillator.
                * @example
                * var omniOsc = new OmniOscillator(440, "fmsquare");
                * omniOsc.sourceType // 'fm'
                */
            sourceType: OmniOscSourceType;
            /**
                * The base type of the oscillator.
                * @example
                * var omniOsc = new OmniOscillator(440, "fmsquare4");
                * omniOsc.sourceType // 'fm'
                * omniOsc.baseType //'square'
                * omniOsc.partialCount //4
                */
            baseType: OscillatorType | "pwm" | "pulse";
            /**
                * The width of the oscillator when sourceType === "pulse".
                * @example
                * var omniOsc = new OmniOscillator(440, "pulse");
                * //can access the width attribute only if type === "pulse"
                * omniOsc.width.value = 0.2;
                */
            readonly width: IsPulseOscillator<OscType, Signal<AudioRange>>;
            /**
                * The number of detuned oscillators, when sourceType === "fat".
                */
            count: IsFatOscillator<OscType, number>;
            /**
                * The detune spread between the oscillators. If "count" is
                * set to 3 oscillators and the "spread" is set to 40,
                * the three oscillators would be detuned like this: [-20, 0, 20]
                * for a total detune spread of 40 cents. See Tone.FatOscillator
                * for more info.
                */
            spread: IsFatOscillator<OscType, Cents>;
            /**
                * The type of the modulator oscillator. Only if the oscillator
                * is set to "am" or "fm" types. see. Tone.AMOscillator or Tone.FMOscillator
                * for more info.
                */
            modulationType: IsAmOrFmOscillator<OscType, ToneOscillatorType>;
            /**
                * The modulation index which is in essence the depth or amount of the modulation. In other terms it is the
                * ratio of the frequency of the modulating signal (mf) to the amplitude of the
                * modulating signal (ma) -- as in ma/mf.
                * See Tone.FMOscillator for more info.
                */
            readonly modulationIndex: IsFMOscillator<OscType, Signal<Positive>>;
            /**
                * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.
                * A harmonicity of 1 gives both oscillators the same frequency.
                * Harmonicity = 2 means a change of an octave. See Tone.AMOscillator or Tone.FMOscillator
                * for more info.
                */
            readonly harmonicity: IsAmOrFmOscillator<OscType, Signal<Positive>>;
            /**
                * The modulationFrequency Signal of the oscillator
                * (only if the oscillator type is set to pwm). See
                * Tone.PWMOscillator for more info.
                * @example
                * var omniOsc = new OmniOscillator(440, "pwm");
                * //can access the modulationFrequency attribute only if type === "pwm"
                * omniOsc.modulationFrequency.value = 0.2;
                * @min 0.1
                * @max 5
                */
            readonly modulationFrequency: IsPWMOscillator<OscType, Signal<Frequency>>;
            asArray(length?: number): Promise<Float32Array>;
            dispose(): this;
    }
}

declare module 'tone/source/oscillator/ToneOscillatorNode' {
    import { Param } from "tone/core/context/Param";
    import { Cents, Frequency, Seconds, Time } from "tone/core/type/Units";
    import { OneShotSource, OneShotSourceOptions } from "tone/source/OneShotSource";
    export interface ToneOscillatorNodeOptions extends OneShotSourceOptions {
            frequency: Frequency;
            detune: Cents;
            type: OscillatorType;
    }
    /**
        * Wrapper around the native fire-and-forget OscillatorNode.
        * Adds the ability to reschedule the stop method.
        * ***[[Oscillator]] is better for most use-cases***
        * @category Source
        */
    export class ToneOscillatorNode extends OneShotSource<ToneOscillatorNodeOptions> {
            readonly name: string;
            protected _internalChannels: OscillatorNode[];
            /**
                * The frequency of the oscillator
                */
            readonly frequency: Param<Frequency>;
            /**
                * The detune of the oscillator
                */
            readonly detune: Param<Cents>;
            /**
                * @param  frequency   The frequency value
                * @param  type  The basic oscillator type
                */
            constructor(frequency: Frequency, type: OscillatorType);
            constructor(options?: Partial<ToneOscillatorNodeOptions>);
            static getDefaults(): ToneOscillatorNodeOptions;
            /**
                * Start the oscillator node at the given time
                * @param  time When to start the oscillator
                */
            start(time?: Time): this;
            protected _stopSource(time?: Seconds): void;
            /**
                * Sets an arbitrary custom periodic waveform given a PeriodicWave.
                * @param  periodicWave PeriodicWave should be created with context.createPeriodicWave
                */
            setPeriodicWave(periodicWave: PeriodicWave): this;
            /**
                * The oscillator type. Either 'sine', 'sawtooth', 'square', or 'triangle'
                */
            type: OscillatorType;
            /**
                * Clean up.
                */
            dispose(): this;
    }
}

declare module 'tone/source/oscillator/LFO' {
    import { Param } from "tone/core/context/Param";
    import { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    import { Degrees, Frequency, NormalRange, Time, UnitName } from "tone/core/type/Units";
    import { BasicPlaybackState } from "tone/core/util/StateTimeline";
    import { Signal } from "tone/signal/Signal";
    import { ToneOscillatorType } from "tone/source/oscillator/Oscillator";
    export interface LFOOptions extends ToneAudioNodeOptions {
            type: ToneOscillatorType;
            min: number;
            max: number;
            phase: Degrees;
            frequency: Frequency;
            amplitude: NormalRange;
            units: UnitName;
    }
    /**
        * LFO stands for low frequency oscillator. LFO produces an output signal
        * which can be attached to an AudioParam or Tone.Signal
        * in order to modulate that parameter with an oscillator. The LFO can
        * also be synced to the transport to start/stop and change when the tempo changes.
        *
        * @example
        * var lfo = new LFO("4n", 400, 4000);
        * lfo.connect(filter.frequency);
        * @category Source
        */
    export class LFO extends ToneAudioNode<LFOOptions> {
            readonly name: string;
            /**
                * The amplitude of the LFO, which controls the output range between
                * the min and max output. For example if the min is -10 and the max
                * is 10, setting the amplitude to 0.5 would make the LFO modulate
                * between -5 and 5.
                */
            readonly amplitude: Param<NormalRange>;
            /**
                * The output of the LFO
                */
            readonly output: OutputNode;
            /**
                * There is no input node
                */
            readonly input: undefined;
            /**
                * If the input value is converted using the [[units]]
                */
            convert: boolean;
            /**
                * The frequency value of the LFO
                */
            readonly frequency: Signal<Frequency>;
            /**
                * @param frequency The frequency of the oscillation.
                * Typically, LFOs will be in the frequency range of 0.1 to 10 hertz.
                * @param min The minimum output value of the LFO.
                * @param max The maximum value of the LFO.
                */
            constructor(frequency?: Frequency, min?: number, max?: number);
            constructor(options?: Partial<LFOOptions>);
            static getDefaults(): LFOOptions;
            /**
                * Start the LFO.
                * @param time The time the LFO will start
                */
            start(time?: Time): this;
            /**
                * Stop the LFO.
                * @param  time The time the LFO will stop
                */
            stop(time?: Time): this;
            /**
                * Sync the start/stop/pause to the transport
                * and the frequency to the bpm of the transport
                * @example
                * lfo.frequency.value = "8n";
                * lfo.sync().start(0)
                * //the rate of the LFO will always be an eighth note,
                * //even as the tempo changes
                */
            sync(): this;
            /**
                * unsync the LFO from transport control
                */
            unsync(): this;
            /**
                * The minimum output of the LFO.
                */
            min: number;
            /**
                * The maximum output of the LFO.
                */
            max: number;
            /**
                * The type of the oscillator: sine, square, sawtooth, triangle.
                */
            type: ToneOscillatorType;
            /**
                * The phase of the LFO.
                */
            phase: Degrees;
            /**
                * The output units of the LFO.
                */
            units: UnitName;
            /**
                * Returns the playback state of the source, either "started" or "stopped".
                */
            readonly state: BasicPlaybackState;
            /**
                * @param node the destination to connect to
                * @param outputNum the optional output number
                * @param inputNum the input number
                */
            connect(node: InputNode, outputNum?: number, inputNum?: number): this;
            dispose(): this;
    }
}

declare module 'tone/source/buffer/ToneBufferSource' {
    import { Param } from "tone/core/context/Param";
    import { ToneAudioBuffer } from "tone/core/context/ToneAudioBuffer";
    import { GainFactor, Positive, Seconds, Time } from "tone/core/type/Units";
    import { OneShotSource, OneShotSourceCurve, OneShotSourceOptions } from "tone/source/OneShotSource";
    export type ToneBufferSourceCurve = OneShotSourceCurve;
    export interface ToneBufferSourceOptions extends OneShotSourceOptions {
            buffer: ToneAudioBuffer;
            curve: ToneBufferSourceCurve;
            playbackRate: Positive;
            fadeIn: Time;
            fadeOut: Time;
            loopStart: Time;
            loopEnd: Time;
            loop: boolean;
            onload: () => void;
    }
    /**
        * Wrapper around the native BufferSourceNode.
        * @category Source
        */
    export class ToneBufferSource extends OneShotSource<ToneBufferSourceOptions> {
            readonly name: string;
            protected _internalChannels: AudioBufferSourceNode[];
            /**
                * The frequency of the oscillator
                */
            readonly playbackRate: Param<Positive>;
            /**
                * @param buffer The buffer to play
                * @param onload The callback to invoke when the buffer is done playing.
                */
            constructor(buffer?: ToneAudioBuffer | AudioBuffer | string, onload?: () => void);
            constructor(options?: Partial<ToneBufferSourceOptions>);
            static getDefaults(): ToneBufferSourceOptions;
            /**
                * The fadeIn time of the amplitude envelope.
                */
            fadeIn: Time;
            /**
                * The fadeOut time of the amplitude envelope.
                */
            fadeOut: Time;
            /**
                * The curve applied to the fades, either "linear" or "exponential"
                */
            curve: ToneBufferSourceCurve;
            /**
                * Start the buffer
                * @param  time When the player should start.
                * @param  offset The offset from the beginning of the sample to start at.
                * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)
                * @param  gain  The gain to play the buffer back at.
                */
            start(time?: Time, offset?: Time, duration?: Time, gain?: GainFactor): this;
            protected _stopSource(time?: Seconds): void;
            /**
                * If loop is true, the loop will start at this position.
                */
            loopStart: Time;
            /**
                * If loop is true, the loop will end at this position.
                */
            loopEnd: Time;
            /**
                * The audio buffer belonging to the player.
                */
            buffer: ToneAudioBuffer;
            /**
                * If the buffer should loop once it's over.
                */
            loop: boolean;
            /**
                * Clean up.
                */
            dispose(): this;
    }
}

declare module 'tone/source/buffer/Player' {
    import { ToneAudioBuffer } from "tone/core/context/ToneAudioBuffer";
    import { Positive, Time } from "tone/core/type/Units";
    import { Source, SourceOptions } from "tone/source/Source";
    export interface PlayerOptions extends SourceOptions {
            onload: () => void;
            playbackRate: Positive;
            loop: boolean;
            autostart: boolean;
            loopStart: Time;
            loopEnd: Time;
            reverse: boolean;
            fadeIn: Time;
            fadeOut: Time;
            url?: ToneAudioBuffer | string | AudioBuffer;
    }
    /**
        * Player is an audio file player with start, loop, and stop functions.
        * @example
        * var player = new Player("./path/to/sample.mp3").toDestination();
        * //play as soon as the buffer is loaded
        * player.autostart = true;
        * @category Source
        */
    export class Player extends Source<PlayerOptions> {
            readonly name: string;
            /**
                * If the file should play as soon
                * as the buffer is loaded.
                * @example
                * //will play as soon as it's loaded
                * var player = new Player({
                * 	"url" : "./path/to/sample.mp3",
                * 	"autostart" : true,
                * }).toDestination();
                */
            autostart: boolean;
            /**
                * The fadeIn time of the amplitude envelope.
                */
            fadeIn: Time;
            /**
                * The fadeOut time of the amplitude envelope.
                */
            fadeOut: Time;
            /**
                * @param url Either the AudioBuffer or the url from which to load the AudioBuffer
                * @param onload The function to invoke when the buffer is loaded.
                */
            constructor(url?: string | AudioBuffer | ToneAudioBuffer, onload?: () => void);
            constructor(options?: Partial<PlayerOptions>);
            static getDefaults(): PlayerOptions;
            /**
                * Load the audio file as an audio buffer.
                * Decodes the audio asynchronously and invokes
                * the callback once the audio buffer loads.
                * Note: this does not need to be called if a url
                * was passed in to the constructor. Only use this
                * if you want to manually load a new url.
                * @param url The url of the buffer to load. Filetype support depends on the browser.
                */
            load(url: string): Promise<this>;
            /**
                * Play the buffer at the given startTime. Optionally add an offset
                * and/or duration which will play the buffer from a position
                * within the buffer for the given duration.
                *
                * @param  time When the player should start.
                * @param  offset The offset from the beginning of the samplem to start at.
                * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)
                */
            start(time?: Time, offset?: Time, duration?: Time): this;
            /**
                * Internal start method
                */
            protected _start(startTime?: Time, offset?: Time, duration?: Time): void;
            /**
                * Stop playback.
                */
            protected _stop(time?: Time): void;
            /**
                * Stop and then restart the player from the beginning (or offset)
                * @param  time When the player should start.
                * @param  offset The offset from the beginning of the sample to start at.
                * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)
                */
            restart(time?: Time, offset?: Time, duration?: Time): this;
            /**
                * Seek to a specific time in the player's buffer. If the
                * source is no longer playing at that time, it will stop.
                * If you seek to a time that
                * @param offset The time to seek to.
                * @param when The time for the seek event to occur.
                * @example
                * source.start(0.2);
                * source.stop(0.4);
                */
            seek(offset: Time, when?: Time): this;
            /**
                * Set the loop start and end. Will only loop if loop is set to true.
                * @param loopStart The loop end time
                * @param loopEnd The loop end time
                * @example
                * //loop 0.1 seconds of the file.
                * player.setLoopPoints(0.2, 0.3);
                * player.loop = true;
                */
            setLoopPoints(loopStart: Time, loopEnd: Time): this;
            /**
                * If loop is true, the loop will start at this position.
                */
            loopStart: Time;
            /**
                * If loop is true, the loop will end at this position.
                */
            loopEnd: Time;
            /**
                * The audio buffer belonging to the player.
                */
            buffer: ToneAudioBuffer;
            /**
                * If the buffer should loop once it's over.
                */
            loop: boolean;
            /**
                * The playback speed. 1 is normal speed. This is not a signal because
                * Safari and iOS currently don't support playbackRate as a signal.
                */
            playbackRate: Positive;
            /**
                * The direction the buffer should play in
                */
            reverse: boolean;
            /**
                * If the buffer is loaded
                */
            readonly loaded: boolean;
            dispose(): this;
    }
}

declare module 'tone/source/buffer/Players' {
    import { Param } from "tone/core/context/Param";
    import { ToneAudioBuffer } from "tone/core/context/ToneAudioBuffer";
    import { ToneAudioBuffersUrlMap } from "tone/core/context/ToneAudioBuffers";
    import { OutputNode, ToneAudioNode } from "tone/core/context/ToneAudioNode";
    import { Decibels, Time } from "tone/core/type/Units";
    import { BasicPlaybackState } from "tone/core/util/StateTimeline";
    import { SourceOptions } from "tone/source/Source";
    import { Player } from "tone/source/buffer/Player";
    export interface PlayersOptions extends SourceOptions {
            urls: ToneAudioBuffersUrlMap;
            volume: Decibels;
            mute: boolean;
            onload: () => void;
            baseUrl: string;
            fadeIn: Time;
            fadeOut: Time;
    }
    /**
        * Players combines multiple [[Player]] objects.
        * @category Source
        */
    export class Players extends ToneAudioNode<PlayersOptions> {
            readonly name: string;
            /**
                * The volume of the output in decibels.
                * @example
                * source.volume.value = -6;
                */
            readonly volume: Param<Decibels>;
            /**
                * The combined output of all of the players
                */
            readonly output: OutputNode;
            /**
                * Players has no input.
                */
            readonly input: undefined;
            /**
                * @param urls An object mapping a name to a url.
                * @param onload The function to invoke when all buffers are loaded.
                */
            constructor(urls?: ToneAudioBuffersUrlMap, onload?: () => void);
            /**
                * @param urls An object mapping a name to a url.
                * @param options The remaining options associated with the players
                */
            constructor(urls?: ToneAudioBuffersUrlMap, options?: Partial<Omit<PlayersOptions, "urls">>);
            constructor(options?: Partial<GainOptions>);
            static getDefaults(): PlayersOptions;
            /**
                * Mute the output.
                * @example
                * //mute the output
                * source.mute = true;
                */
            mute: boolean;
            /**
                * The fadeIn time of the envelope applied to the source.
                */
            fadeIn: Time;
            /**
                * The fadeOut time of the each of the sources.
                */
            fadeOut: Time;
            /**
                * The state of the players object. Returns "started" if any of the players are playing.
                */
            readonly state: BasicPlaybackState;
            /**
                * True if the buffers object has a buffer by that name.
                * @param name  The key or index of the buffer.
                */
            has(name: string): boolean;
            /**
                * Get a player by name.
                * @param  name  The players name as defined in the constructor object or `add` method.
                */
            player(name: string): Player;
            /**
                * If all the buffers are loaded or not
                */
            readonly loaded: boolean;
            /**
                * Add a player by name and url to the Players
                * @param  name A unique name to give the player
                * @param  url  Either the url of the bufer or a buffer which will be added with the given name.
                * @param callback  The callback to invoke when the url is loaded.
                */
            add(name: string, url: string | ToneAudioBuffer | AudioBuffer, callback?: () => void): this;
            /**
                * Stop all of the players at the given time
                * @param time The time to stop all of the players.
                */
            stopAll(time?: Time): this;
            dispose(): this;
    }
}

declare module 'tone/source/buffer/GrainPlayer' {
    import { Source, SourceOptions } from "tone/source/Source";
    import { ToneAudioBuffer } from "tone/core/context/ToneAudioBuffer";
    import { Cents, Positive, Seconds, Time } from "tone/core/type/Units";
    interface GrainPlayerOptions extends SourceOptions {
            onload: () => void;
            reverse: boolean;
            url?: ToneAudioBuffer | string | AudioBuffer;
            overlap: Seconds;
            grainSize: Seconds;
            playbackRate: Positive;
            detune: Cents;
            loop: boolean;
            loopStart: Time;
            loopEnd: Time;
    }
    /**
        * GrainPlayer implements [granular synthesis](https://en.wikipedia.org/wiki/Granular_synthesis).
        * Granular Synthesis enables you to adjust pitch and playback rate independently. The grainSize is the
        * amount of time each small chunk of audio is played for and the overlap is the
        * amount of crossfading transition time between successive grains.
        * @category Source
        */
    export class GrainPlayer extends Source<GrainPlayerOptions> {
            readonly name: string;
            /**
                * The audio buffer belonging to the player.
                */
            buffer: ToneAudioBuffer;
            /**
                * Adjust the pitch independently of the playbackRate.
                */
            detune: Cents;
            /**
                * If the buffer should loop back to the loopStart when completed
                */
            loop: boolean;
            /**
                * @param url Either the AudioBuffer or the url from which to load the AudioBuffer
                * @param onload The function to invoke when the buffer is loaded.
                */
            constructor(url?: string | AudioBuffer | ToneAudioBuffer, onload?: () => void);
            constructor(options?: Partial<GrainPlayerOptions>);
            static getDefaults(): GrainPlayerOptions;
            /**
                * Internal start method
                */
            protected _start(time?: Time, offset?: Time, duration?: Time): void;
            /**
                * Stop and then restart the player from the beginning (or offset)
                * @param  time When the player should start.
                * @param  offset The offset from the beginning of the sample to start at.
                * @param  duration How long the sample should play. If no duration is given,
                * 					it will default to the full length of the sample (minus any offset)
                */
            restart(time?: Time, offset?: Time, duration?: Time): this;
            /**
                * Internal stop method
                */
            protected _stop(time?: Time): void;
            /**
                * The playback rate of the sample
                */
            playbackRate: Positive;
            /**
                * The loop start time.
                */
            loopStart: Time;
            /**
                * The loop end time.
                */
            loopEnd: Time;
            /**
                * The direction the buffer should play in
                */
            reverse: boolean;
            /**
                * The size of each chunk of audio that the
                * buffer is chopped into and played back at.
                */
            grainSize: Time;
            /**
                * The duration of the cross-fade between successive grains.
                */
            overlap: Time;
            /**
                * If all the buffer is loaded
                */
            readonly loaded: boolean;
            dispose(): this;
    }
    export {};
}

declare module 'tone/signal/Add' {
    import { Gain } from "tone/core/context/Gain";
    import { Param } from "tone/core/context/Param";
    import { Signal, SignalOptions } from "tone/signal/Signal";
    /**
        * Add a signal and a number or two signals. When no value is
        * passed into the constructor, Tone.Add will sum input and `addend`
        * If a value is passed into the constructor, the it will be added to the input.
        *
        * @example
        * var signal = new Signal(2);
        * var add = new Add(2);
        * signal.connect(add);
        * //the output of add equals 4
        * @example
        * //if constructed with no arguments
        * //it will add the first and second inputs
        * var add = new Add();
        * var sig0 = new Signal(3).connect(add);
        * var sig1 = new Signal(4).connect(add.addend);
        * //the output of add equals 7.
        * @category Signal
        */
    export class Add extends Signal {
            override: boolean;
            readonly name: string;
            readonly input: Gain<number>;
            readonly output: Gain<number>;
            /**
                * The value which is added to the input signal
                */
            readonly addend: Param<number>;
            /**
                * @param value If no value is provided, Tone.Add will sum the first  and second inputs.
                */
            constructor(value?: number);
            constructor(options?: Partial<SignalOptions<number>>);
            static getDefaults(): SignalOptions<number>;
            dispose(): this;
    }
}

declare module 'tone/signal/Abs' {
    import { ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    import { SignalOperator } from "tone/signal/SignalOperator";
    import { WaveShaper } from "tone/signal/WaveShaper";
    /**
        * Return the absolute value of an incoming signal.
        *
        * @example
        * var signal = new Tone.Signal(-1);
        * var abs = new Tone.Abs();
        * signal.connect(abs);
        * //the output of abs is 1.
        * @category Signal
        */
    export class Abs extends SignalOperator<ToneAudioNodeOptions> {
            readonly name: string;
            /**
                * The AudioRange input [-1, 1]
                */
            input: WaveShaper;
            /**
                * The output range [0, 1]
                */
            output: WaveShaper;
            /**
                * clean up
                */
            dispose(): this;
    }
}

declare module 'tone/signal/AudioToGain' {
    import { ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    import { SignalOperator } from "tone/signal/SignalOperator";
    import { WaveShaper } from "tone/signal/WaveShaper";
    /**
        * AudioToGain converts an input in AudioRange [-1,1] to NormalRange [0,1].
        * See {@link GainToAudio}.
        *
        * @example
        * var a2g = new AudioToGain();
        * @category Signal
        */
    export class AudioToGain extends SignalOperator<ToneAudioNodeOptions> {
            readonly name: string;
            /**
                * The AudioRange input [-1, 1]
                */
            input: WaveShaper;
            /**
                * The GainRange output [0, 1]
                */
            output: WaveShaper;
            /**
                * clean up
                */
            dispose(): this;
    }
}

declare module 'tone/signal/GainToAudio' {
    import { ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    import { SignalOperator } from "tone/signal/SignalOperator";
    import { WaveShaper } from "tone/signal/WaveShaper";
    /**
        * GainToAudio converts an input in NormalRange [0,1] to AudioRange [-1,1].
        * See {@link AudioToGain}.
        *
        * @example
        * var a2g = new GainToAudio();
        * @category Signal
        */
    export class GainToAudio extends SignalOperator<ToneAudioNodeOptions> {
            readonly name: string;
            /**
                * The NormalRange input [0, 1]
                */
            input: WaveShaper;
            /**
                * The AudioRange output [-1, 1]
                */
            output: WaveShaper;
            /**
                * clean up
                */
            dispose(): this;
    }
}

declare module 'tone/signal/Multiply' {
    import { Gain } from "tone/core/context/Gain";
    import { Param } from "tone/core/context/Param";
    import { Signal, SignalOptions } from "tone/signal/Signal";
    /**
        * Multiply two incoming signals. Or, if a number is given in the constructor,
        * multiplies the incoming signal by that value.
        *
        * @example
        * const mult = new Multiply();
        * const sigA = new Tone.Signal(3);
        * const sigB = new Tone.Signal(4);
        * sigA.connect(mult);
        * sigB.connect(mult.factor);
        * //output of mult is 12.
        * @example
        * const mult = new Multiply(10);
        * const sig = new Tone.Signal(2).connect(mult);
        * //the output of mult is 20.
        * @category Signal
        */
    export class Multiply extends Signal<number> {
            readonly name: string;
            /**
                * Indicates if the value should be overridden on connection
                */
            readonly override = false;
            /**
                * The multiplicand input.
                */
            input: Gain<number>;
            /**
                * The product of the input and {@link factor}
                */
            output: Gain<number>;
            /**
                * The multiplication factor. Can be set directly or a signal can be connected to it.
                */
            factor: Param<number>;
            /**
                * @param value Constant value to multiple
                */
            constructor(value?: number);
            constructor(options?: Partial<SignalOptions<number>>);
            static getDefaults(): SignalOptions<number>;
            dispose(): this;
    }
}

declare module 'tone/signal/Negate' {
    import { ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    import { Multiply } from "tone/signal/Multiply";
    import { SignalOperator } from "tone/signal/SignalOperator";
    /**
        * Negate the incoming signal. i.e. an input signal of 10 will output -10
        *
        * @example
        * var neg = new Negate();
        * var sig = new Signal(-2).connect(neg);
        * //output of neg is positive 2.
        * @category Signal
        */
    export class Negate extends SignalOperator<ToneAudioNodeOptions> {
            readonly name: string;
            /**
                * The input and output are equal to the multiply node
                */
            input: Multiply;
            output: Multiply;
            /**
                * clean up
                * @returns {Negate} this
                */
            dispose(): this;
    }
}

declare module 'tone/signal/Signal' {
    import { AbstractParam } from "tone/core/context/AbstractParam";
    import { Param } from "tone/core/context/Param";
    import { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    import { Time, Unit, UnitName } from "tone/core/type/Units";
    import { ToneConstantSource } from "tone/signal/ToneConstantSource";
    export interface SignalOptions<Type> extends ToneAudioNodeOptions {
            value: Type;
            units: UnitName;
            convert: boolean;
    }
    /**
        * A signal is an audio-rate value. Tone.Signal is a core component of the library.
        * Unlike a number, Signals can be scheduled with sample-level accuracy. Tone.Signal
        * has all of the methods available to native Web Audio
        * [AudioParam](http://webaudio.github.io/web-audio-api/#the-audioparam-interface)
        * as well as additional conveniences. Read more about working with signals
        * [here](https://github.com/Tonejs/Tone.js/wiki/Signals).
        *
        * @example
        * const signal = new Tone.Signal(10);
        * @category Signal
        */
    export class Signal<Type extends Unit = number> extends ToneAudioNode<SignalOptions<any>> implements AbstractParam<Type> {
            readonly name: string;
            /**
                * Indicates if the value should be overridden on connection.
                */
            readonly override: boolean;
            /**
                * The constant source node which generates the signal
                */
            protected _constantSource: ToneConstantSource<Type>;
            readonly output: OutputNode;
            protected _param: Param<Type>;
            readonly input: InputNode;
            /**
                * @param value Initial value of the signal
                * @param units The unit name, e.g. "frequency"
                */
            constructor(value?: Type, units?: UnitName);
            constructor(options?: Partial<SignalOptions<Type>>);
            static getDefaults(): SignalOptions<any>;
            connect(destination: InputNode, outputNum?: number, inputNum?: number): this;
            dispose(): this;
            setValueAtTime(value: Type, time: Time): this;
            getValueAtTime(time: Time): Type;
            setRampPoint(time: Time): this;
            linearRampToValueAtTime(value: Type, time: Time): this;
            exponentialRampToValueAtTime(value: Type, time: Time): this;
            exponentialRampTo(value: Type, rampTime: Time, startTime?: Time): this;
            linearRampTo(value: Type, rampTime: Time, startTime?: Time): this;
            targetRampTo(value: Type, rampTime: Time, startTime?: Time): this;
            exponentialApproachValueAtTime(value: Type, time: Time, rampTime: Time): this;
            setTargetAtTime(value: Type, startTime: Time, timeConstant: number): this;
            setValueCurveAtTime(values: Type[], startTime: Time, duration: Time, scaling?: number): this;
            cancelScheduledValues(time: Time): this;
            cancelAndHoldAtTime(time: Time): this;
            rampTo(value: Type, rampTime: Time, startTime?: Time): this;
            value: Type;
            convert: boolean;
            readonly units: UnitName;
            overridden: boolean;
            readonly maxValue: number;
            readonly minValue: number;
            /**
                * See [[Param.apply]].
                */
            apply(param: Param | AudioParam): this;
    }
    /**
        * When connecting from a signal, it's necessary to zero out the node destination
        * node if that node is also a signal. If the destination is not 0, then the values
        * will be summed. This method insures that the output of the destination signal will
        * be the same as the source signal, making the destination signal a pass through node.
        * @param signal The output signal to connect from
        * @param destination the destination to connect to
        * @param outputNum the optional output number
        * @param inputNum the input number
        */
    export function connectSignal(signal: OutputNode, destination: InputNode, outputNum?: number, inputNum?: number): void;
}

declare module 'tone/signal/Subtract' {
    import { Gain } from "tone/core/context/Gain";
    import { Param } from "tone/core/context/Param";
    import { Signal, SignalOptions } from "tone/signal/Signal";
    /**
        * Subtract the signal connected to the input is subtracted from the signal connected
        * The subtrahend.
        *
        * @example
        * var sub = new Subtract(1);
        * var sig = new Tone.Signal(4).connect(sub);
        * //the output of sub is 3.
        * @example
        * var sub = new Subtract();
        * var sigA = new Tone.Signal(10);
        * var sigB = new Tone.Signal(2.5);
        * sigA.connect(sub);
        * sigB.connect(sub.subtrahend);
        * //output of sub is 7.5
        * @category Signal
        */
    export class Subtract extends Signal {
            override: boolean;
            readonly name: string;
            readonly input: Gain;
            readonly output: Gain;
            /**
                * The value which is subtracted from the main signal
                */
            subtrahend: Param<number>;
            /**
                * @param value The value to subtract from the incoming signal. If the value
                *             is omitted, it will subtract the second signal from the first.
                */
            constructor(value?: number);
            constructor(options?: Partial<SignalOptions<number>>);
            static getDefaults(): SignalOptions<number>;
            dispose(): this;
    }
}

declare module 'tone/signal/WaveShaper' {
    import { ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    import { SignalOperator } from "tone/signal/SignalOperator";
    export type WaveShaperMappingFn = (value: number, index?: number) => number;
    type WaveShaperMapping = WaveShaperMappingFn | number[] | Float32Array;
    interface WaveShaperOptions extends ToneAudioNodeOptions {
            mapping?: WaveShaperMapping;
            length: number;
            curve?: number[] | Float32Array;
    }
    /**
        * Wraps the native Web Audio API
        * [WaveShaperNode](http://webaudio.github.io/web-audio-api/#the-waveshapernode-interface).
        *
        * @example
        * var timesTwo = new WaveShaper(function(val){
        * 	return val * 2;
        * }, 2048);
        * @example
        * //a waveshaper can also be constructed with an array of values
        * var invert = new WaveShaper([1, -1]);
        * @category Signal
        */
    export class WaveShaper extends SignalOperator<WaveShaperOptions> {
            readonly name: string;
            /**
                * The input to the waveshaper node.
                */
            input: WaveShaperNode;
            /**
                * The output from the waveshaper node
                */
            output: WaveShaperNode;
            /**
                * @param mapping The function used to define the values.
                *                The mapping function should take two arguments:
                *                the first is the value at the current position
                *                and the second is the array position.
                *                If the argument is an array, that array will be
                *                set as the wave shaping function. The input
                *                signal is an AudioRange [-1, 1] value and the output
                *                signal can take on any numerical values.
                *
                * @param bufferLen The length of the WaveShaperNode buffer.
                */
            constructor(mapping?: WaveShaperMapping, length?: number);
            constructor(options?: Partial<WaveShaperOptions>);
            static getDefaults(): WaveShaperOptions;
            /**
                * Uses a mapping function to set the value of the curve.
                * @param mapping The function used to define the values.
                *                The mapping function take two arguments:
                *                the first is the value at the current position
                *                which goes from -1 to 1 over the number of elements
                *                in the curve array. The second argument is the array position.
                * @example
                * //map the input signal from [-1, 1] to [0, 10]
                * shaper.setMap(function(val, index){
                * 	return (val + 1) * 5;
                * })
                */
            setMap(mapping: WaveShaperMappingFn, length?: number): this;
            /**
                * The array to set as the waveshaper curve. For linear curves
                * array length does not make much difference, but for complex curves
                * longer arrays will provide smoother interpolation.
                */
            curve: Float32Array | null;
            /**
                * Specifies what type of oversampling (if any) should be used when
                * applying the shaping curve. Can either be "none", "2x" or "4x".
                */
            oversample: OverSampleType;
            /**
                * Clean up.
                */
            dispose(): this;
    }
    export {};
}

declare module 'tone/signal/Zero' {
    import { Gain } from "tone/core/context/Gain";
    import { ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    import { SignalOperator } from "tone/signal/SignalOperator";
    /**
        * Tone.Zero outputs 0's at audio-rate. The reason this has to be
        * it's own class is that many browsers optimize out Tone.Signal
        * with a value of 0 and will not process nodes further down the graph.
        * @category Signal
        */
    export class Zero extends SignalOperator<ToneAudioNodeOptions> {
            readonly name: string;
            /**
                * Only outputs 0
                */
            output: Gain<number>;
            /**
                * no input node
                */
            input: undefined;
            constructor(options?: Partial<ToneAudioNodeOptions>);
            /**
                * clean up
                */
            dispose(): this;
    }
}

declare module 'tone/instrument/Synth' {
    import { AmplitudeEnvelope } from "tone/component/envelope/AmplitudeEnvelope";
    import { EnvelopeOptions } from "tone/component/envelope/Envelope";
    import { ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    import { Cents, Frequency, Seconds } from "tone/core/type/Units";
    import { RecursivePartial } from "tone/core/util/Interface";
    import { Signal } from "tone/signal/Signal";
    import { OmniOscillator } from "tone/source/oscillator/OmniOscillator";
    import { OmniOscillatorSynthOptions } from "tone/source/oscillator/OscillatorInterface";
    import { Monophonic, MonophonicOptions } from "tone/instrument/Monophonic";
    export interface SynthOptions extends MonophonicOptions {
            oscillator: OmniOscillatorSynthOptions;
            envelope: Omit<EnvelopeOptions, keyof ToneAudioNodeOptions>;
    }
    /**
        * Synth is composed simply of a {@link OmniOscillator} routed through an {@link AmplitudeEnvelope}.
        * ```
        * +----------------+   +-------------------+
        * | OmniOscillator +>--> AmplitudeEnvelope +>--> Output
        * +----------------+   +-------------------+
        * ```
        * @example
        * var synth = new Synth().toDestination();
        * synth.triggerAttackRelease("C4", "8n");
        * @category Instrument
        */
    export class Synth<Options extends SynthOptions = SynthOptions> extends Monophonic<Options> {
            readonly name: string;
            /**
                * The oscillator.
                */
            readonly oscillator: OmniOscillator<any>;
            /**
                * The frequency signal
                */
            readonly frequency: Signal<Frequency>;
            /**
                * The detune signal
                */
            readonly detune: Signal<Cents>;
            /**
                * The envelope
                */
            readonly envelope: AmplitudeEnvelope;
            /**
                * @param options the options available for the synth.
                */
            constructor(options?: RecursivePartial<SynthOptions>);
            static getDefaults(): SynthOptions;
            /**
                * start the attack portion of the envelope
                * @param time the time the attack should start
                * @param velocity the velocity of the note (0-1)
                */
            protected _triggerEnvelopeAttack(time: Seconds, velocity: number): void;
            /**
                * start the release portion of the envelope
                * @param time the time the release should start
                */
            protected _triggerEnvelopeRelease(time: Seconds): void;
            /**
                * clean up
                */
            dispose(): this;
    }
}

declare module 'tone/instrument/Sampler' {
    import { ToneAudioBuffer } from "tone/core/context/ToneAudioBuffer";
    import { Frequency, MidiNote, NormalRange, Note, Time } from "tone/core/type/Units";
    import { Instrument, InstrumentOptions } from "tone/instrument/Instrument";
    import { ToneBufferSourceCurve } from "tone/source/buffer/ToneBufferSource";
    interface SamplesMap {
            [note: string]: ToneAudioBuffer | AudioBuffer | string;
            [midi: number]: ToneAudioBuffer | AudioBuffer | string;
    }
    export interface SamplerOptions extends InstrumentOptions {
            attack: Time;
            release: Time;
            onload: () => void;
            baseUrl: string;
            curve: ToneBufferSourceCurve;
            urls: SamplesMap;
    }
    /**
        * Pass in an object which maps the note's pitch or midi value to the url,
        * then you can trigger the attack and release of that note like other instruments.
        * By automatically repitching the samples, it is possible to play pitches which
        * were not explicitly included which can save loading time.
        *
        * For sample or buffer playback where repitching is not necessary,
        * use [[Player]].
        * @example
        * var sampler = new Sampler({
        * 	"C3" : "path/to/C3.mp3",
        * 	"D#3" : "path/to/Dsharp3.mp3",
        * 	"F#3" : "path/to/Fsharp3.mp3",
        * 	"A3" : "path/to/A3.mp3",
        * }, function(){
        * 	//sampler will repitch the closest sample
        * 	sampler.triggerAttack("D3")
        * })
        * @category Instrument
        */
    export class Sampler extends Instrument<SamplerOptions> {
            readonly name: string;
            /**
                * The envelope applied to the beginning of the sample.
                * @min 0
                * @max 1
                */
            attack: Time;
            /**
                * The envelope applied to the end of the envelope.
                * @min 0
                * @max 1
                */
            release: Time;
            /**
                * The shape of the attack/release curve.
                * Either "linear" or "exponential"
                */
            curve: ToneBufferSourceCurve;
            /**
                * @param samples An object of samples mapping either Midi Note Numbers or
                * 			Scientific Pitch Notation to the url of that sample.
                * @param onload The callback to invoke when all of the samples are loaded.
                * @param baseUrl The root URL of all of the samples, which is prepended to all the URLs.
                */
            constructor(samples?: SamplesMap, onload?: () => void, baseUrl?: string);
            /**
                * @param samples An object of samples mapping either Midi Note Numbers or
                * 			Scientific Pitch Notation to the url of that sample.
                * @param options The remaining options associated with the sampler
                */
            constructor(samples?: SamplesMap, options?: Partial<Omit<SamplerOptions, "urls">>);
            constructor(options?: Partial<SamplerOptions>);
            static getDefaults(): SamplerOptions;
            /**
                * @param  notes	The note to play, or an array of notes.
                * @param  time     When to play the note
                * @param  velocity The velocity to play the sample back.
                */
            triggerAttack(notes: Frequency | Frequency[], time?: Time, velocity?: NormalRange): this;
            /**
                * @param  notes	The note to release, or an array of notes.
                * @param  time     	When to release the note.
                */
            triggerRelease(notes: Frequency | Frequency[], time?: Time): this;
            /**
                * Release all currently active notes.
                * @param  time     	When to release the notes.
                */
            releaseAll(time?: Time): this;
            /**
                * Sync the instrument to the Transport. All subsequent calls of
                * [[triggerAttack]] and [[triggerRelease]]
                * will be scheduled along the transport.
                * @example
                * synth.sync()
                * //schedule 3 notes when the transport first starts
                * synth.triggerAttackRelease('8n', 0)
                * synth.triggerAttackRelease('8n', '8n')
                * synth.triggerAttackRelease('8n', '4n')
                * //start the transport to hear the notes
                * Transport.start()
                * @returns {Tone.Instrument} this
                */
            sync(): this;
            /**
                * Invoke the attack phase, then after the duration, invoke the release.
                * @param  notes	The note to play and release, or an array of notes.
                * @param  duration The time the note should be held
                * @param  time     When to start the attack
                * @param  velocity The velocity of the attack
                */
            triggerAttackRelease(notes: Frequency[] | Frequency, duration: Time | Time[], time?: Time, velocity?: NormalRange): this;
            /**
                * Add a note to the sampler.
                * @param  note      The buffer's pitch.
                * @param  url  Either the url of the buffer, or a buffer which will be added with the given name.
                * @param  callback  The callback to invoke when the url is loaded.
                */
            add(note: Note | MidiNote, url: string | ToneAudioBuffer | AudioBuffer, callback?: () => void): this;
            /**
                * If the buffers are loaded or not
                */
            readonly loaded: boolean;
            /**
                * Clean up
                */
            dispose(): this;
    }
    export {};
}

declare module 'tone/instrument/PolySynth' {
    import { Frequency, NormalRange, Time } from "tone/core/type/Units";
    import { RecursivePartial } from "tone/core/util/Interface";
    import { Instrument, InstrumentOptions } from "tone/instrument/Instrument";
    import { MembraneSynth, MembraneSynthOptions } from "tone/instrument/MembraneSynth";
    import { FMSynth, FMSynthOptions } from "tone/instrument/FMSynth";
    import { MetalSynth, MetalSynthOptions } from "tone/instrument/MetalSynth";
    import { Monophonic } from "tone/instrument/Monophonic";
    import { Synth, SynthOptions } from "tone/instrument/Synth";
    type VoiceConstructor<V> = {
            getDefaults: () => VoiceOptions<V>;
    } & (new (...args: any[]) => V);
    type OmitMonophonicOptions<T> = Omit<T, "context" | "onsilence">;
    type VoiceOptions<T> = T extends MembraneSynth ? MembraneSynthOptions : T extends MetalSynth ? MetalSynthOptions : T extends FMSynth ? FMSynthOptions : T extends Synth ? SynthOptions : never;
    /**
        * The settable synth options. excludes monophonic options.
        */
    type PartialVoiceOptions<T> = RecursivePartial<OmitMonophonicOptions<VoiceOptions<T>>>;
    export interface PolySynthOptions<Voice> extends InstrumentOptions {
            maxPolyphony: number;
            voice: VoiceConstructor<Voice>;
            options: PartialVoiceOptions<Voice>;
    }
    /**
        * PolySynth handles voice creation and allocation for any
        * instruments passed in as the second paramter. PolySynth is
        * not a synthesizer by itself, it merely manages voices of
        * one of the other types of synths, allowing any of the
        * monophonic synthesizers to be polyphonic.
        *
        * @example
        * var synth = new PolySynth(Tone.Synth, {
        *   oscillator : {
        * 		type : "square"
        * 	}
        * }).toMaster();
        * //set the attributes using the set interface
        * synth.set("detune", -1200);
        * //play a chord
        * synth.triggerAttackRelease(["C4", "E4", "A4"], "4n");
        * @category Instrument
        */
    export class PolySynth<Voice extends Monophonic<any> = Synth> extends Instrument<VoiceOptions<Voice>> {
            readonly name: string;
            /**
                * The polyphony limit.
                */
            maxPolyphony: number;
            /**
                * @param voice The constructor of the voices
                * @param options	The options object to set the synth voice
                */
            constructor(voice?: VoiceConstructor<Voice>, options?: PartialVoiceOptions<Voice>);
            constructor(options?: Partial<PolySynthOptions<Voice>>);
            static getDefaults(): PolySynthOptions<Synth>;
            /**
                * The number of active voices.
                */
            readonly activeVoices: number;
            /**
                * Trigger the attack portion of the note
                * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.
                * @param  time  The start time of the note.
                * @param velocity The velocity of the note.
                * @example
                * //trigger a chord immediately with a velocity of 0.2
                * poly.triggerAttack(["Ab3", "C4", "F5"], undefined, 0.2);
                */
            triggerAttack(notes: Frequency | Frequency[], time?: Time, velocity?: NormalRange): this;
            /**
                * Trigger the release of the note. Unlike monophonic instruments,
                * a note (or array of notes) needs to be passed in as the first argument.
                * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.
                * @param  time  When the release will be triggered.
                * @example
                * poly.triggerRelease(["Ab3", "C4", "F5"], "+2n");
                */
            triggerRelease(notes: Frequency | Frequency[], time?: Time): this;
            /**
                * Trigger the attack and release after the specified duration
                * @param  notes The notes to play. Accepts a single  Frequency or an array of frequencies.
                * @param  duration the duration of the note
                * @param  time  if no time is given, defaults to now
                * @param  velocity the velocity of the attack (0-1)
                * @example
                * //trigger a chord for a duration of a half note
                * poly.triggerAttackRelease(["Eb3", "G4", "C5"], "2n");
                * @example
                * //can pass in an array of durations as well
                * poly.triggerAttackRelease(["Eb3", "G4", "C5"], ["2n", "4n", "4n"]);
                */
            triggerAttackRelease(notes: Frequency | Frequency[], duration: Time | Time[], time?: Time, velocity?: NormalRange): this;
            /**
                * Sync the instrument to the Transport. All subsequent calls of
                * {@link triggerAttack} and {@link triggerRelease} will be scheduled along the transport.
                * @example
                * synth.sync()
                * //schedule 3 notes when the transport first starts
                * synth.triggerAttackRelease('8n', 0)
                * synth.triggerAttackRelease('8n', '8n')
                * synth.triggerAttackRelease('8n', '4n')
                * //start the transport to hear the notes
                * Transport.start()
                */
            sync(): this;
            /**
                * Set a member/attribute of the voices
                * @example
                * poly.set({
                * 	"filter" : {
                * 		"type" : "highpass"
                * 	},
                * 	"envelope" : {
                * 		"attack" : 0.25
                * 	}
                * });
                */
            set(options: RecursivePartial<VoiceOptions<Voice>>): this;
            get(): VoiceOptions<Voice>;
            /**
                * Trigger the release portion of all the currently active voices immediately.
                * Useful for silencing the synth.
                */
            releaseAll(): this;
            dispose(): this;
    }
    export {};
}

declare module 'tone/instrument/MembraneSynth' {
    import { FrequencyClass } from "tone/core/type/Frequency";
    import { Frequency, Positive, Time } from "tone/core/type/Units";
    import { RecursivePartial } from "tone/core/util/Interface";
    import { Synth, SynthOptions } from "tone/instrument/Synth";
    export interface MembraneSynthOptions extends SynthOptions {
            pitchDecay: Time;
            octaves: Positive;
    }
    /**
        * MembraneSynth makes kick and tom sounds using a single oscillator
        * with an amplitude envelope and frequency ramp. A Tone.OmniOscillator
        * is routed through a Tone.AmplitudeEnvelope to the output. The drum
        * quality of the sound comes from the frequency envelope applied
        * during MembraneSynth.triggerAttack(note). The frequency envelope
        * starts at <code>note * .octaves</code> and ramps to <code>note</code>
        * over the duration of <code>.pitchDecay</code>.
        * @example
        * var synth = new MembraneSynth().toMaster();
        * synth.triggerAttackRelease("C2", "8n");
        * @category Instrument
        */
    export class MembraneSynth extends Synth<MembraneSynthOptions> {
            readonly name: string;
            /**
                * The number of octaves the pitch envelope ramps.
                * @min 0.5
                * @max 8
                */
            octaves: Positive;
            /**
                * The amount of time the frequency envelope takes.
                * @min 0
                * @max 0.5
                */
            pitchDecay: Time;
            /**
                * Portamento is ignored in this synth. use pitch decay instead.
                */
            readonly portamento = 0;
            /**
                * @param options the options available for the synth see defaults
                */
            constructor(options?: RecursivePartial<MembraneSynthOptions>);
            static getDefaults(): MembraneSynthOptions;
            setNote(note: Frequency | FrequencyClass, time?: Time): this;
            dispose(): this;
    }
}

declare module 'tone/instrument/MetalSynth' {
    import { Envelope, EnvelopeOptions } from "tone/component/envelope/Envelope";
    import { ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    import { Cents, Frequency, NormalRange, Positive, Seconds } from "tone/core/type/Units";
    import { RecursivePartial } from "tone/core/util/Interface";
    import { Signal } from "tone/signal/Signal";
    import { Monophonic, MonophonicOptions } from "tone/instrument/Monophonic";
    export interface MetalSynthOptions extends MonophonicOptions {
            harmonicity: Positive;
            modulationIndex: Positive;
            octaves: number;
            resonance: Frequency;
            envelope: Omit<EnvelopeOptions, keyof ToneAudioNodeOptions>;
    }
    /**
        * A highly inharmonic and spectrally complex source with a highpass filter
        * and amplitude envelope which is good for making metallophone sounds.
        * Based on CymbalSynth by [@polyrhythmatic](https://github.com/polyrhythmatic).
        * Inspiration from [Sound on Sound](https://shorturl.at/rSZ12).
        * @category Instrument
        */
    export class MetalSynth extends Monophonic<MetalSynthOptions> {
            readonly name: string;
            /**
                * The frequency of the cymbal
                */
            readonly frequency: Signal<Frequency>;
            /**
                * The detune applied to the oscillators
                */
            readonly detune: Signal<Cents>;
            /**
                * The envelope which is connected both to the
                * amplitude and a highpass filter's cutoff frequency.
                * The lower-limit of the filter is controlled by the [[resonance]]
                */
            readonly envelope: Envelope;
            constructor(options?: RecursivePartial<MetalSynthOptions>);
            static getDefaults(): MetalSynthOptions;
            /**
                * Trigger the attack.
                * @param time When the attack should be triggered.
                * @param velocity The velocity that the envelope should be triggered at.
                */
            protected _triggerEnvelopeAttack(time: Seconds, velocity?: NormalRange): this;
            /**
                * Trigger the release of the envelope.
                * @param time When the release should be triggered.
                */
            protected _triggerEnvelopeRelease(time: Seconds): this;
            /**
                * The modulationIndex of the oscillators which make up the source.
                * see [[FMOscillator.modulationIndex]]
                * @min 1
                * @max 100
                */
            modulationIndex: number;
            /**
                * The harmonicity of the oscillators which make up the source.
                * see Tone.FMOscillator.harmonicity
                * @min 0.1
                * @max 10
                */
            harmonicity: number;
            /**
                * The lower level of the highpass filter which is attached to the envelope.
                * This value should be between [0, 7000]
                * @min 0
                * @max 7000
                */
            resonance: Frequency;
            /**
                * The number of octaves above the "resonance" frequency
                * that the filter ramps during the attack/decay envelope
                * @min 0
                * @max 8
                */
            octaves: number;
            dispose(): this;
    }
}

declare module 'tone/instrument/PluckSynth' {
    import { Frequency, NormalRange, Time } from "tone/core/type/Units";
    import { RecursivePartial } from "tone/core/util/Interface";
    import { Instrument, InstrumentOptions } from "tone/instrument/Instrument";
    export interface PluckSynthOptions extends InstrumentOptions {
            attackNoise: number;
            dampening: Frequency;
            resonance: NormalRange;
            release: Time;
    }
    /**
        * Karplus-String string synthesis.
        * @example
        * var plucky = new Tone.PluckSynth().toDestination();
        * plucky.triggerAttack("C4");
        * @category Instrument
        */
    export class PluckSynth extends Instrument<PluckSynthOptions> {
            readonly name = "PluckSynth";
            /**
                * The amount of noise at the attack.
                * Nominal range of [0.1, 20]
                * @min 0.1
                * @max 20
                */
            attackNoise: number;
            /**
                * The amount of resonance of the pluck. Also correlates to the sustain duration.
                */
            resonance: NormalRange;
            /**
                * The release time which corresponds to a resonance ramp down to 0
                */
            release: Time;
            constructor(options?: RecursivePartial<PluckSynthOptions>);
            static getDefaults(): PluckSynthOptions;
            /**
                * The dampening control. i.e. the lowpass filter frequency of the comb filter
                * @min 0
                * @max 7000
                */
            dampening: Frequency;
            triggerAttack(note: Frequency, time?: Time): this;
            /**
                * Ramp down the [[resonance]] to 0 over the duration of the release time.
                */
            triggerRelease(time?: Time): this;
            dispose(): this;
    }
}

declare module 'tone/instrument/FMSynth' {
    import { AmplitudeEnvelope } from "tone/component/envelope/AmplitudeEnvelope";
    import { EnvelopeOptions } from "tone/component/envelope/Envelope";
    import { ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    import { Cents, Frequency, Positive, Seconds } from "tone/core/type/Units";
    import { RecursivePartial } from "tone/core/util/Interface";
    import { Monophonic } from "tone/instrument/Monophonic";
    import { Multiply } from "tone/signal/Multiply";
    import { Signal } from "tone/signal/Signal";
    import { OmniOscillator } from "tone/source/oscillator/OmniOscillator";
    import { OmniOscillatorSynthOptions } from "tone/source/oscillator/OscillatorInterface";
    import { SynthOptions } from "tone/instrument/Synth";
    export interface FMSynthOptions extends SynthOptions {
            harmonicity: Positive;
            modulationIndex: Positive;
            modulationEnvelope: Omit<EnvelopeOptions, keyof ToneAudioNodeOptions>;
            modulation: OmniOscillatorSynthOptions;
    }
    /**
        * FMSynth is composed of two Tone.Synths where one Tone.Synth modulates
        * the frequency of a second Tone.Synth. A lot of spectral content
        * can be explored using the modulationIndex parameter. Read more about
        * frequency modulation synthesis on Sound On Sound: [Part 1](https://web.archive.org/web/20160403123704/http://www.soundonsound.com/sos/apr00/articles/synthsecrets.htm), [Part 2](https://web.archive.org/web/20160403115835/http://www.soundonsound.com/sos/may00/articles/synth.htm).
        *
        * @example
        * var fmSynth = new Tone.FMSynth().toMaster();
        * fmSynth.triggerAttackRelease("C5", "4n");
        */
    export class FMSynth extends Monophonic<FMSynthOptions> {
            readonly name: string;
            /**
                * The carrier's oscillator
                */
            readonly oscillator: OmniOscillator<any>;
            /**
                * The carrier's envelope
                */
            readonly envelope: AmplitudeEnvelope;
            /**
                * The modulator's oscillator which is applied to the amplitude of the oscillator
                */
            readonly modulation: OmniOscillator<any>;
            /**
                * The modulator's envelope
                */
            readonly modulationEnvelope: AmplitudeEnvelope;
            /**
                * The frequency control
                */
            readonly frequency: Signal<Frequency>;
            /**
                * The detune in cents
                */
            readonly detune: Signal<Cents>;
            /**
                * Harmonicity is the ratio between the two voices. A harmonicity of
                * 1 is no change. Harmonicity = 2 means a change of an octave.
                * @example
                * // pitch voice1 an octave below voice0
                * synth.harmonicity.value = 0.5;
                */
            readonly harmonicity: Multiply;
            /**
                * The modulation index which essentially the depth or amount of the modulation. It is the
                * ratio of the frequency of the modulating signal (mf) to the amplitude of the
                * modulating signal (ma) -- as in ma/mf.
                */
            readonly modulationIndex: Multiply;
            constructor(options?: RecursivePartial<FMSynthOptions>);
            static getDefaults(): FMSynthOptions;
            /**
                * Trigger the attack portion of the note
                */
            protected _triggerEnvelopeAttack(time: Seconds, velocity: number): void;
            /**
                * Trigger the release portion of the note
                */
            protected _triggerEnvelopeRelease(time: Seconds): this;
            dispose(): this;
    }
}

declare module 'tone/instrument/NoiseSynth' {
    import { AmplitudeEnvelope } from "tone/component/envelope/AmplitudeEnvelope";
    import { NormalRange, Time } from "tone/core/type/Units";
    import { RecursivePartial } from "tone/core/util/Interface";
    import { Noise, NoiseOptions } from "tone/source/Noise";
    import { Instrument, InstrumentOptions } from "tone/instrument/Instrument";
    import { ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    import { EnvelopeOptions } from "tone/component/envelope/Envelope";
    export interface NoiseSynthOptions extends InstrumentOptions {
            envelope: Omit<EnvelopeOptions, keyof ToneAudioNodeOptions>;
            noise: Omit<NoiseOptions, keyof ToneAudioNodeOptions>;
    }
    /**
        * Tone.NoiseSynth is composed of [[Noise]] through an [[AmplitudeEnvelope]].
        * ```
        * +-------+   +-------------------+
        * | Noise +>--> AmplitudeEnvelope +>--> Output
        * +-------+   +-------------------+
        * ```
        * @example
        * var noiseSynth = new Tone.NoiseSynth().toMaster();
        * noiseSynth.triggerAttackRelease("8n");
        * @category Instrument
        */
    export class NoiseSynth extends Instrument<NoiseSynthOptions> {
            readonly name = "NoiseSynth";
            /**
                * The noise source.
                */
            readonly noise: Noise;
            /**
                * The amplitude envelope.
                */
            readonly envelope: AmplitudeEnvelope;
            constructor(options?: RecursivePartial<NoiseSynthOptions>);
            static getDefaults(): NoiseSynthOptions;
            /**
                * Start the attack portion of the envelopes. Unlike other
                * instruments, Tone.NoiseSynth doesn't have a note.
                * @example
                * noiseSynth.triggerAttack();
                */
            triggerAttack(time?: Time, velocity?: NormalRange): this;
            /**
                * Start the release portion of the envelopes.
                */
            triggerRelease(time?: Time): this;
            /**
                * Sync the instrument to the Transport. All subsequent calls of
                * [triggerAttack](#triggerattack) and [triggerRelease](#triggerrelease)
                * will be scheduled along the transport.
                * @example
                * synth.sync()
                * //schedule 3 notes when the transport first starts
                * synth.triggerAttackRelease('8n', 0)
                * synth.triggerAttackRelease('8n', '8n')
                * synth.triggerAttackRelease('8n', '4n')
                * //start the transport to hear the notes
                * Transport.start()
                */
            sync(): this;
            triggerAttackRelease(duration: Time, time: Time, velocity?: NormalRange): this;
            dispose(): this;
    }
}

declare module 'tone/event/Part' {
    import { TransportTimeClass } from "tone/core/type/TransportTime";
    import { NormalRange, Positive, Seconds, Ticks, Time, TransportTime } from "tone/core/type/Units";
    import { StateTimeline } from "tone/core/util/StateTimeline";
    import { ToneEvent, ToneEventCallback, ToneEventOptions } from "tone/event/ToneEvent";
    type CallbackType<T> = T extends {
            time: Time;
            [key: string]: any;
    } ? T : T extends ArrayLike<any> ? T[1] : T extends Time ? null : never;
    interface PartOptions<T> extends Omit<ToneEventOptions<CallbackType<T>>, "value"> {
            events: T[];
    }
    /**
        * Part is a collection ToneEvents which can be started/stopped and looped as a single unit.
        *
        * @example
        * var part = new Part(function(time, note){
        * 	//the notes given as the second element in the array
        * 	//will be passed in as the second argument
        * 	synth.triggerAttackRelease(note, "8n", time);
        * }, [[0, "C2"], ["0:2", "C3"], ["0:3:2", "G2"]]);
        * @example
        * //use an array of objects as long as the object has a "time" attribute
        * var part = new Part(function(time, value){
        * 	//the value is an object which contains both the note and the velocity
        * 	synth.triggerAttackRelease(value.note, "8n", time, value.velocity);
        * }, [{"time" : 0, "note" : "C3", "velocity": 0.9},
        * {"time" : "0:2", "note" : "C4", "velocity": 0.5}
        * ]).start(0);
        * @category Event
        */
    export class Part<ValueType = any> extends ToneEvent<ValueType> {
            readonly name: string;
            /**
                * Tracks the scheduled events
                */
            protected _state: StateTimeline<{
                    id: number;
                    offset: number;
            }>;
            /**
                * @param callback The callback to invoke on each event
                * @param events the array of events
                */
            constructor(callback?: ToneEventCallback<CallbackType<ValueType>>, value?: ValueType[]);
            constructor(options?: Partial<PartOptions<ValueType>>);
            static getDefaults(): PartOptions<any>;
            /**
                * Start the part at the given time.
                * @param  time    When to start the part.
                * @param  offset  The offset from the start of the part to begin playing at.
                */
            start(time?: TransportTime, offset?: Time): this;
            startOffset: Ticks;
            /**
                * Stop the part at the given time.
                * @param  time  When to stop the part.
                */
            stop(time?: TransportTime): this;
            /**
                * Get/Set an Event's value at the given time.
                * If a value is passed in and no event exists at
                * the given time, one will be created with that value.
                * If two events are at the same time, the first one will
                * be returned.
                * @example
                * part.at("1m"); //returns the part at the first measure
                * part.at("2m", "C2"); //set the value at "2m" to C2.
                * //if an event didn't exist at that time, it will be created.
                * @param time The time of the event to get or set.
                * @param value If a value is passed in, the value of the event at the given time will be set to it.
                */
            at(time: Time, value?: any): ToneEvent | null;
            /**
                * Add a an event to the part.
                * @param time The time the note should start. If an object is passed in, it should
                * 		have a 'time' attribute and the rest of the object will be used as the 'value'.
                * @param  value
                * @example
                * part.add("1m", "C#+11");
                * @example
                * part.add({
                * 	time: "1m",
                * 	note: "C#11"
                * });
                */
            add(obj: {
                    time: Time;
                    [key: string]: any;
            }): this;
            add(time: Time, value?: any): this;
            /**
                * Remove an event from the part. If the event at that time is a Part,
                * it will remove the entire part.
                * @param time The time of the event
                * @param value Optionally select only a specific event value
                */
            remove(obj: {
                    time: Time;
                    [key: string]: any;
            }): this;
            remove(time: Time, value?: any): this;
            /**
                * Remove all of the notes from the group.
                */
            clear(): this;
            /**
                * Cancel scheduled state change events: i.e. "start" and "stop".
                * @param after The time after which to cancel the scheduled events.
                */
            cancel(after?: TransportTime | TransportTimeClass): this;
            /**
                * Internal tick method
                * @param  time  The time of the event in seconds
                */
            protected _tick(time: Seconds, value?: any): void;
            /**
                * The probability of the notes being triggered.
                */
            probability: NormalRange;
            /**
                * If set to true, will apply small random variation
                * to the callback time. If the value is given as a time, it will randomize
                * by that amount.
                * @example
                * event.humanize = true;
                */
            humanize: boolean | Time;
            /**
                * If the part should loop or not
                * between Part.loopStart and
                * Part.loopEnd. If set to true,
                * the part will loop indefinitely,
                * if set to a number greater than 1
                * it will play a specific number of
                * times, if set to false, 0 or 1, the
                * part will only play once.
                * @example
                * //loop the part 8 times
                * part.loop = 8;
                */
            loop: boolean | number;
            /**
                * The loopEnd point determines when it will
                * loop if Part.loop is true.
                * @memberOf Part#
                * @type {Time}
                * @name loopEnd
                */
            loopEnd: Time;
            /**
                * The loopStart point determines when it will
                * loop if Part.loop is true.
                */
            loopStart: Time;
            /**
                * The playback rate of the part
                */
            playbackRate: Positive;
            /**
                * The number of scheduled notes in the part.
                */
            readonly length: number;
            dispose(): this;
    }
    export {};
}

declare module 'tone/event/Sequence' {
    import { NormalRange, Positive, Seconds, Ticks, Time, TransportTime } from "tone/core/type/Units";
    import { ToneEvent, ToneEventCallback, ToneEventOptions } from "tone/event/ToneEvent";
    type SequenceEventDescription<T> = Array<T | T[]>;
    interface SequenceOptions<T> extends Omit<ToneEventOptions<T>, "value"> {
            loopStart: number;
            loopEnd: number;
            subdivision: Time;
            events: SequenceEventDescription<T>;
    }
    /**
        * A sequence is an alternate notation of a part. Instead
        * of passing in an array of [time, event] pairs, pass
        * in an array of events which will be spaced at the
        * given subdivision. Sub-arrays will subdivide that beat
        * by the number of items are in the array.
        * Sequence notation inspiration from [Tidal](http://yaxu.org/tidal/)
        * @example
        * var seq = new Sequence(function(time, note){
        * 	console.log(note);
        * //straight quater notes
        * }, ["C4", "E4", "G4", "A4"], "4n");
        * @example
        * var seq = new Sequence(function(time, note){
        * 	console.log(note);
        * //subdivisions are given as subarrays
        * }, ["C4", ["E4", "D4", "E4"], "G4", ["A4", "G4"]]);
        * @category Event
        */
    export class Sequence<ValueType = any> extends ToneEvent<ValueType> {
            readonly name: string;
            /**
                * @param  callback  The callback to invoke with every note
                * @param  sequence  The sequence
                * @param  subdivision  The subdivision between which events are placed.
                */
            constructor(callback?: ToneEventCallback<ValueType>, events?: SequenceEventDescription<ValueType>, subdivision?: Time);
            constructor(options?: Partial<SequenceOptions<ValueType>>);
            static getDefaults(): SequenceOptions<any>;
            /**
                * The sequence
                */
            events: any[];
            /**
                * Start the part at the given time.
                * @param  time    When to start the part.
                * @param  offset  The offset index to start at
                */
            start(time?: TransportTime, offset?: number): this;
            /**
                * Stop the part at the given time.
                * @param  time  When to stop the part.
                */
            stop(time?: TransportTime): this;
            /**
                * The subdivision of the sequence. This can only be
                * set in the constructor. The subdivision is the
                * interval between successive steps.
                */
            readonly subdivision: Seconds;
            /**
                * Clear all of the events
                */
            clear(): this;
            dispose(): this;
            loop: boolean | number;
            /**
                * The index at which the sequence should start looping
                */
            loopStart: number;
            /**
                * The index at which the sequence should end looping
                */
            loopEnd: number;
            startOffset: Ticks;
            playbackRate: Positive;
            probability: NormalRange;
            humanize: boolean | Time;
            /**
                * The number of scheduled events
                */
            readonly length: number;
    }
    export {};
}

declare module 'tone/event/ToneEvent' {
    import "../core/clock/Transport";
    import { ToneWithContext, ToneWithContextOptions } from "tone/core/context/ToneWithContext";
    import { TransportTimeClass } from "tone/core/type/TransportTime";
    import { NormalRange, Positive, Seconds, Ticks, Time, TransportTime } from "tone/core/type/Units";
    import { BasicPlaybackState, StateTimeline } from "tone/core/util/StateTimeline";
    export type ToneEventCallback<T> = (time: Seconds, value: T) => void;
    export interface ToneEventOptions<T> extends ToneWithContextOptions {
            callback: ToneEventCallback<T>;
            loop: boolean | number;
            loopEnd: Time;
            loopStart: Time;
            playbackRate: Positive;
            value?: T;
            probability: NormalRange;
            mute: boolean;
            humanize: boolean | Time;
    }
    /**
        * ToneEvent abstracts away this.context.transport.schedule and provides a schedulable
        * callback for a single or repeatable events along the timeline.
        *
        * @example
        * var chord = new ToneEvent(function(time, chord){
        * 	//the chord as well as the exact time of the event
        * 	//are passed in as arguments to the callback function
        * }, ["D4", "E4", "F4"]);
        * //start the chord at the beginning of the transport timeline
        * chord.start();
        * //loop it every measure for 8 measures
        * chord.loop = 8;
        * chord.loopEnd = "1m";
        * @category Event
        */
    export class ToneEvent<ValueType = any> extends ToneWithContext<ToneEventOptions<ValueType>> {
            readonly name: string;
            /**
                * Loop value
                */
            protected _loop: boolean | number;
            /**
                * The callback to invoke.
                */
            callback: ToneEventCallback<ValueType>;
            /**
                * The value which is passed to the
                * callback function.
                */
            value: ValueType;
            /**
                * When the note is scheduled to start.
                */
            protected _loopStart: Ticks;
            /**
                * When the note is scheduled to start.
                */
            protected _loopEnd: Ticks;
            /**
                * Tracks the scheduled events
                */
            protected _state: StateTimeline<{
                    id: number;
            }>;
            /**
                * The playback speed of the note. A speed of 1
                * is no change.
                */
            protected _playbackRate: Positive;
            /**
                * A delay time from when the event is scheduled to start
                */
            protected _startOffset: Ticks;
            /**
                * private holder of probability value
                */
            protected _probability: NormalRange;
            /**
                * the amount of variation from the given time.
                */
            protected _humanize: boolean | Time;
            /**
                * If mute is true, the callback won't be invoked.
                */
            mute: boolean;
            /**
                * @param callback The callback to invoke at the time.
                * @param value The value or values which should be passed to the callback function on invocation.
                */
            constructor(callback?: ToneEventCallback<ValueType>, value?: ValueType);
            constructor(options?: Partial<ToneEventOptions<ValueType>>);
            static getDefaults(): ToneEventOptions<any>;
            /**
                * Returns the playback state of the note, either "started" or "stopped".
                */
            readonly state: BasicPlaybackState;
            /**
                * The start from the scheduled start time.
                */
            startOffset: Ticks;
            /**
                * The probability of the notes being triggered.
                */
            probability: NormalRange;
            /**
                * If set to true, will apply small random variation
                * to the callback time. If the value is given as a time, it will randomize
                * by that amount.
                * @example
                * event.humanize = true;
                */
            humanize: Time | boolean;
            /**
                * Start the note at the given time.
                * @param  time  When the event should start.
                */
            start(time?: TransportTime | TransportTimeClass): this;
            /**
                * Stop the Event at the given time.
                * @param  time  When the event should stop.
                */
            stop(time?: TransportTime | TransportTimeClass): this;
            /**
                * Cancel all scheduled events greater than or equal to the given time
                * @param  time  The time after which events will be cancel.
                */
            cancel(time?: TransportTime | TransportTimeClass): this;
            /**
                * The callback function invoker. Also
                * checks if the Event is done playing
                * @param  time  The time of the event in seconds
                */
            protected _tick(time: Seconds): void;
            /**
                * Get the duration of the loop.
                */
            protected _getLoopDuration(): Ticks;
            /**
                * If the note should loop or not
                * between ToneEvent.loopStart and
                * ToneEvent.loopEnd. If set to true,
                * the event will loop indefinitely,
                * if set to a number greater than 1
                * it will play a specific number of
                * times, if set to false, 0 or 1, the
                * part will only play once.
                */
            loop: boolean | number;
            /**
                * The playback rate of the note. Defaults to 1.
                * @example
                * note.loop = true;
                * //repeat the note twice as fast
                * note.playbackRate = 2;
                */
            playbackRate: Positive;
            /**
                * The loopEnd point is the time the event will loop
                * if ToneEvent.loop is true.
                */
            loopEnd: Time;
            /**
                * The time when the loop should start.
                */
            loopStart: Time;
            /**
                * The current progress of the loop interval.
                * Returns 0 if the event is not started yet or
                * it is not set to loop.
                */
            readonly progress: NormalRange;
            dispose(): this;
    }
}

declare module 'tone/event/Loop' {
    import { NormalRange, Positive, Seconds, Time, TransportTime } from "tone/core/type/Units";
    import { ToneWithContext, ToneWithContextOptions } from "tone/core/context/ToneWithContext";
    import { BasicPlaybackState } from "tone/core/util/StateTimeline";
    export interface LoopOptions extends ToneWithContextOptions {
            callback: (time: Seconds) => void;
            interval: Time;
            playbackRate: Positive;
            iterations: number;
            probability: NormalRange;
            mute: boolean;
            humanize: boolean | Time;
    }
    /**
        * Loop creates a looped callback at the
        * specified interval. The callback can be
        * started, stopped and scheduled along
        * the Transport's timeline.
        * @example
        * var loop = new Loop(function(time){
        * 	//triggered every eighth note.
        * 	console.log(time);
        * }, "8n").start(0);
        * Tone.Transport.start();
        * @category Event
        */
    export class Loop extends ToneWithContext<LoopOptions> {
            readonly name: string;
            /**
                * The callback to invoke with the next event in the pattern
                */
            callback: (time: Seconds) => void;
            /**
                * @param callback The callback to invoke at the time.
                * @param interval The time between successive callback calls.
                */
            constructor(callback?: (time: Seconds) => void, interval?: Time);
            constructor(options?: Partial<LoopOptions>);
            static getDefaults(): LoopOptions;
            /**
                * Start the loop at the specified time along the Transport's timeline.
                * @param  time  When to start the Loop.
                */
            start(time?: TransportTime): this;
            /**
                * Stop the loop at the given time.
                * @param  time  When to stop the Loop.
                */
            stop(time?: TransportTime): this;
            /**
                * Cancel all scheduled events greater than or equal to the given time
                * @param  time  The time after which events will be cancel.
                */
            cancel(time?: TransportTime): this;
            /**
                * The state of the Loop, either started or stopped.
                */
            readonly state: BasicPlaybackState;
            /**
                * The progress of the loop as a value between 0-1. 0, when the loop is stopped or done iterating.
                */
            readonly progress: NormalRange;
            /**
                * The time between successive callbacks.
                * @example
                * loop.interval = "8n"; //loop every 8n
                */
            interval: Time;
            /**
                * The playback rate of the loop. The normal playback rate is 1 (no change).
                * A `playbackRate` of 2 would be twice as fast.
                */
            playbackRate: Positive;
            /**
                * Random variation +/-0.01s to the scheduled time.
                * Or give it a time value which it will randomize by.
                */
            humanize: boolean | Time;
            /**
                * The probably of the callback being invoked.
                */
            probability: NormalRange;
            /**
                * Muting the Loop means that no callbacks are invoked.
                */
            mute: boolean;
            /**
                * The number of iterations of the loop. The default value is `Infinity` (loop forever).
                */
            iterations: number;
            dispose(): this;
    }
}

declare module 'tone/effect/FeedbackDelay' {
    import { Param } from "tone/core/context/Param";
    import { NormalRange, Time } from "tone/core/type/Units";
    import { FeedbackEffect, FeedbackEffectOptions } from "tone/effect/FeedbackEffect";
    interface FeedbackDelayOptions extends FeedbackEffectOptions {
            delayTime: Time;
            maxDelay: Time;
    }
    /**
        * FeedbackDelay is a DelayNode in which part of output signal is fed back into the delay.
        *
        * @param delayTime The delay applied to the incoming signal.
        * @param feedback The amount of the effected signal which is fed back through the delay.
        * @example
        * var feedbackDelay = new FeedbackDelay("8n", 0.5).toDestination();
        * var tom = new Tone.MembraneSynth({
        * "octaves" : 4,
        * "pitchDecay" : 0.1
        * }).connect(feedbackDelay);
        * tom.triggerAttackRelease("A2","32n");
        * @category Effect
        */
    export class FeedbackDelay extends FeedbackEffect<FeedbackDelayOptions> {
            readonly name: string;
            /**
                * The delayTime of the FeedbackDelay.
                */
            readonly delayTime: Param<Time>;
            constructor(delayTime?: Time, feedback?: NormalRange);
            constructor(options?: Partial<FeedbackDelayOptions>);
            static getDefaults(): FeedbackDelayOptions;
            dispose(): this;
    }
    export {};
}

declare module 'tone/effect/Reverb' {
    import { Seconds } from "tone/core/type/Units";
    import { Effect, EffectOptions } from "tone/effect/Effect";
    interface ReverbOptions extends EffectOptions {
            decay: Seconds;
            preDelay: Seconds;
    }
    /**
        * Simple convolution created with decaying noise.
        * Generates an Impulse Response Buffer
        * with Tone.Offline then feeds the IR into ConvolverNode.
        * Note: the Reverb will not make any sound until [[generate]]
        * has been invoked and resolved.
        *
        * Inspiration from [ReverbGen](https://github.com/adelespinasse/reverbGen).
        * Copyright (c) 2014 Alan deLespinasse Apache 2.0 License.
        *
        * @category Effect
        */
    export class Reverb extends Effect<ReverbOptions> {
            readonly name: string;
            /**
                * The duration of the reverb.
                * [[generate]] must be called in order to update the values.
                */
            decay: Seconds;
            /**
                * The amount of time before the reverb is fully ramped in.
                * [[generate]] must be called in order to update the values.
                */
            preDelay: Seconds;
            /**
                * @param decay The amount of time it will reverberate for.
                */
            constructor(decay?: Seconds);
            constructor(options?: Partial<ReverbOptions>);
            static getDefaults(): ReverbOptions;
            /**
                * Generate the Impulse Response. Returns a promise while the IR is being generated.
                * @return Promise which returns this object.
                */
            generate(): Promise<this>;
            dispose(): this;
    }
    export {};
}

declare module 'tone/effect/Distortion' {
    import { Effect, EffectOptions } from "tone/effect/Effect";
    export interface DistortionOptions extends EffectOptions {
            distortion: number;
            oversample: OverSampleType;
    }
    /**
        * A simple distortion effect using Tone.WaveShaper.
        * Algorithm from [this stackoverflow answer](http://stackoverflow.com/a/22313408).
        *
        * @example
        * var dist = new Distortion(0.8).toMaster();
        * var fm = new Tone.SimpleFM().connect(dist);
        * //this sounds good on bass notes
        * fm.triggerAttackRelease("A1", "8n");
        * @category Effect
        */
    export class Distortion extends Effect<DistortionOptions> {
            readonly name: string;
            /**
                * @param distortion The amount of distortion (nominal range of 0-1)
                */
            constructor(distortion?: number);
            constructor(options?: Partial<DistortionOptions>);
            static getDefaults(): DistortionOptions;
            /**
                * The amount of distortion. Nominal range is between 0 and 1.
                */
            distortion: number;
            /**
                * The oversampling of the effect. Can either be "none", "2x" or "4x".
                */
            oversample: OverSampleType;
            dispose(): this;
    }
}

declare module 'tone/component/analysis/Analyser' {
    import { ToneAudioNode, ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    import { NormalRange, PowerOfTwo } from "tone/core/type/Units";
    export type AnalyserType = "fft" | "waveform";
    export interface AnalyserOptions extends ToneAudioNodeOptions {
            size: PowerOfTwo;
            type: AnalyserType;
            smoothing: NormalRange;
    }
    /**
        * Wrapper around the native Web Audio's [AnalyserNode](http://webaudio.github.io/web-audio-api/#idl-def-AnalyserNode).
        * Extracts FFT or Waveform data from the incoming signal.
        * @category Component
        */
    export class Analyser extends ToneAudioNode<AnalyserOptions> {
            readonly name: string;
            readonly input: AnalyserNode;
            readonly output: AnalyserNode;
            /**
                * @param type The return type of the analysis, either "fft", or "waveform".
                * @param size The size of the FFT. This must be a power of two in the range 16 to 16384.
                */
            constructor(type?: AnalyserType, size?: number);
            constructor(options?: Partial<AnalyserOptions>);
            static getDefaults(): AnalyserOptions;
            /**
                * Run the analysis given the current settings and return the
                */
            getValue(): Float32Array;
            /**
                * The size of analysis. This must be a power of two in the range 16 to 16384.
                */
            size: PowerOfTwo;
            /**
                * The analysis function returned by analyser.getValue(), either "fft" or "waveform".
                */
            type: AnalyserType;
            /**
                * 0 represents no time averaging with the last analysis frame.
                */
            smoothing: NormalRange;
            /**
                * Clean up.
                */
            dispose(): this;
    }
}

declare module 'tone/component/analysis/Meter' {
    import { Decibels, NormalRange } from "tone/core/type/Units";
    import { MeterBase, MeterBaseOptions } from "tone/component/analysis/MeterBase";
    export interface MeterOptions extends MeterBaseOptions {
            smoothing: NormalRange;
    }
    /**
        * Meter gets the [RMS](https://en.wikipedia.org/wiki/Root_mean_square)
        * of an input signal. It can also get the raw value of the input signal.
        *
        * @example
        * import { Meter, UserMedia } from "tone";
        * const meter = new Meter();
        * const mic = new UserMedia();
        * mic.open();
        * // connect mic to the meter
        * mic.connect(meter);
        * // the current level of the mic
        * const level = meter.getValue();
        * @category Component
        */
    export class Meter extends MeterBase<MeterOptions> {
            readonly name: string;
            /**
                * A value from between 0 and 1 where 0 represents no time averaging with the last analysis frame.
                */
            smoothing: number;
            /**
                * @param smoothing The amount of smoothing applied between frames.
                */
            constructor(smoothing?: NormalRange);
            constructor(options?: Partial<MeterOptions>);
            static getDefaults(): MeterOptions;
            /**
                * Use [[getValue]] instead. For the previous getValue behavior, use DCMeter.
                * @deprecated
                */
            getLevel(): Decibels;
            /**
                * Get the current decibel value of the incoming signal
                */
            getValue(): number;
            dispose(): this;
    }
}

declare module 'tone/component/analysis/FFT' {
    import { NormalRange, PowerOfTwo } from "tone/core/type/Units";
    import { MeterBase, MeterBaseOptions } from "tone/component/analysis/MeterBase";
    export interface FFTOptions extends MeterBaseOptions {
            size: PowerOfTwo;
            smoothing: NormalRange;
            normalRange: boolean;
    }
    /**
        * Get the current frequency data of the connected audio source using a fast Fourier transform.
        * @category Component
        */
    export class FFT extends MeterBase<FFTOptions> {
            readonly name: string;
            /**
                * If the output should be in decibels or normal range between 0-1. If `normalRange` is false,
                * the output range will be the measured decibel value, otherwise the decibel value will be converted to
                * the range of 0-1
                */
            normalRange: boolean;
            /**
                * @param size The size of the FFT. Value must be a power of two in the range 16 to 16384.
                */
            constructor(size?: PowerOfTwo);
            constructor(options?: Partial<FFTOptions>);
            static getDefaults(): FFTOptions;
            /**
                * Gets the current frequency data from the connected audio source.
                * Returns the frequency data of length [[size]] as a Float32Array of decibel values.
                */
            getValue(): Float32Array;
            /**
                * The size of analysis. This must be a power of two in the range 16 to 16384.
                * Determines the size of the array returned by [[getValue]] (i.e. the number of
                * frequency bins). Large FFT sizes may be costly to compute.
                */
            size: PowerOfTwo;
            /**
                * 0 represents no time averaging with the last analysis frame.
                */
            smoothing: NormalRange;
    }
}

declare module 'tone/component/analysis/DCMeter' {
    import { MeterBase, MeterBaseOptions } from "tone/component/analysis/MeterBase";
    export type DCMeterOptions = MeterBaseOptions;
    /**
        * DCMeter gets the raw value of the input signal at the current time.
        *
        * @example
        * import { DCMeter, UserMedia } from "tone";
        * const meter = new DCMeter();
        * const mic = new UserMedia();
        * mic.open();
        * // connect mic to the meter
        * mic.connect(meter);
        * // the current level of the mic
        * const level = meter.getValue();
        * @category Component
        */
    export class DCMeter extends MeterBase<DCMeterOptions> {
            readonly name: string;
            constructor(options?: Partial<DCMeterOptions>);
            /**
                * Get the signal value of the incoming signal
                */
            getValue(): number;
    }
}

declare module 'tone/component/analysis/Waveform' {
    import { PowerOfTwo } from "tone/core/type/Units";
    import { MeterBase, MeterBaseOptions } from "tone/component/analysis/MeterBase";
    export interface WaveformOptions extends MeterBaseOptions {
            /**
                * The size of the Waveform. Value must be a power of two in the range 16 to 16384.
                */
            size: PowerOfTwo;
    }
    /**
        * Get the current waveform data of the connected audio source.
        * @category Component
        */
    export class Waveform extends MeterBase<WaveformOptions> {
            readonly name: string;
            /**
                * @param size The size of the Waveform. Value must be a power of two in the range 16 to 16384.
                */
            constructor(size?: PowerOfTwo);
            constructor(options?: Partial<WaveformOptions>);
            static getDefaults(): WaveformOptions;
            /**
                * Return the waveform for the current time as a Float32Array where each value in the array
                * represents a sample in the waveform.
                */
            getValue(): Float32Array;
            /**
                * The size of analysis. This must be a power of two in the range 16 to 16384.
                * Determines the size of the array returned by [[getValue]].
                */
            size: PowerOfTwo;
    }
}

declare module 'tone/component/analysis/Follower' {
    import { Time } from "tone/core/type/Units";
    import { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    export interface FollowerOptions extends ToneAudioNodeOptions {
            smoothing: Time;
    }
    /**
        * Follower is a simple envelope follower.
        * It's implemented by applying a lowpass filter to the absolute value of the incoming signal.
        * ```
        *          +-----+    +---------------+
        * Input +--> Abs +----> OnePoleFilter +--> Output
        *          +-----+    +---------------+
        * ```
        * @category Component
        */
    export class Follower extends ToneAudioNode<FollowerOptions> {
            readonly name: string;
            readonly input: InputNode;
            readonly output: OutputNode;
            /**
                * @param smoothing The rate of change of the follower.
                */
            constructor(smoothing?: Time);
            constructor(options?: Partial<FollowerOptions>);
            static getDefaults(): FollowerOptions;
            /**
                * The amount of time it takes a value change to arrive at the updated value.
                */
            smoothing: Time;
            dispose(): this;
    }
}

declare module 'tone/component/channel/CrossFade' {
    import { Gain } from "tone/core/context/Gain";
    import { ToneAudioNode, ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    import { NormalRange } from "tone/core/type/Units";
    import { Signal } from "tone/signal/Signal";
    interface CrossFadeOptions extends ToneAudioNodeOptions {
            fade: NormalRange;
    }
    /**
        * Tone.Crossfade provides equal power fading between two inputs.
        * More on crossfading technique [here](https://en.wikipedia.org/wiki/Fade_(audio_engineering)#Crossfading).
        * ```
        *                                             +---------+
        *                                            +> input a +>--+
        * +-----------+   +---------------------+     |         |   |
        * | 1s signal +>--> stereoPannerNode  L +>----> gain    |   |
        * +-----------+   |                     |     +---------+   |
        *               +-> pan               R +>-+                |   +--------+
        *               | +---------------------+  |                +---> output +>
        *  +------+     |                          |  +---------+   |   +--------+
        *  | fade +>----+                          | +> input b +>--+
        *  +------+                                |  |         |
        *                                          +--> gain    |
        *                                             +---------+
        * ```
        * @example
        * import { CrossFade, Oscillator } from "tone";
        * const crossFade = new CrossFade().toDestination();
        * // connect two inputs to a/b
        * const inputA = new Oscillator(440, "square").connect(crossFade.a).start();
        * const inputB = new Oscillator(440, "sine").connect(crossFade.b).start();
        * // use the fade to control the mix between the two
        * crossFade.fade.value = 0.5;
        * @category Component
        */
    export class CrossFade extends ToneAudioNode<CrossFadeOptions> {
            readonly name: string;
            /**
                * The input which is at full level when fade = 0
                */
            readonly a: Gain;
            /**
                * The input which is at full level when fade = 1
                */
            readonly b: Gain;
            /**
                * The output is a mix between `a` and `b` at the ratio of `fade`
                */
            readonly output: Gain;
            /**
                * CrossFade has no input, you must choose either `a` or `b`
                */
            readonly input: undefined;
            /**
                * The mix between the two inputs. A fade value of 0
                * will output 100% crossFade.a and
                * a value of 1 will output 100% crossFade.b.
                */
            readonly fade: Signal<NormalRange>;
            protected _internalChannels: Gain<number>[];
            /**
                * @param fade The initial fade value [0, 1].
                */
            constructor(fade?: NormalRange);
            constructor(options?: Partial<CrossFadeOptions>);
            static getDefaults(): CrossFadeOptions;
            dispose(): this;
    }
    export {};
}

declare module 'tone/component/channel/Merge' {
    import { ToneAudioNode, ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    import { Positive } from "tone/core/type/Units";
    interface MergeOptions extends ToneAudioNodeOptions {
            channels: Positive;
    }
    /**
        * Merge brings multiple mono input channels into a single multichannel output channel.
        *
        * @example
        * import { Merge, Noise, Oscillator } from "tone";
        * const merge = new Merge().toDestination();
        * // routing a sine tone in the left channel
        * const osc = new Oscillator().connect(merge, 0, 0).start();
        * // and noise in the right channel
        * const noise = new Noise().connect(merge, 0, 1).start();;
        * @category Component
        */
    export class Merge extends ToneAudioNode<MergeOptions> {
            readonly name: string;
            /**
                * The output is the input channels combined into a sigle (multichannel) output
                */
            readonly output: ChannelMergerNode;
            /**
                * Multiple input connections combine into a single output.
                */
            readonly input: ChannelMergerNode;
            /**
                * @param channels The number of channels to merge.
                */
            constructor(channels?: Positive);
            constructor(options?: Partial<MergeOptions>);
            static getDefaults(): MergeOptions;
            dispose(): this;
    }
    export {};
}

declare module 'tone/component/channel/MultibandSplit' {
    import { Gain } from "tone/core/context/Gain";
    import { ToneAudioNode, ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    import { Frequency, Positive } from "tone/core/type/Units";
    import { Signal } from "tone/signal/Signal";
    import { Filter } from "tone/component/filter/Filter";
    interface MultibandSplitOptions extends ToneAudioNodeOptions {
            Q: Positive;
            lowFrequency: Frequency;
            highFrequency: Frequency;
    }
    /**
        * Split the incoming signal into three bands (low, mid, high)
        * with two crossover frequency controls.
        * ```
        *            +----------------------+
        *          +-> input < lowFrequency +------------------> low
        *          | +----------------------+
        *          |
        *          | +--------------------------------------+
        * input ---+-> lowFrequency < input < highFrequency +--> mid
        *          | +--------------------------------------+
        *          |
        *          | +-----------------------+
        *          +-> highFrequency < input +-----------------> high
        *            +-----------------------+
        * ```
        * @category Component
        */
    export class MultibandSplit extends ToneAudioNode<MultibandSplitOptions> {
            readonly name: string;
            /**
                * the input
                */
            readonly input: Gain<number>;
            /**
                * no output node, use either low, mid or high outputs
                */
            readonly output: undefined;
            /**
                * The low band.
                */
            readonly low: Filter;
            /**
                * The mid band output.
                */
            readonly mid: Filter;
            /**
                * The high band output.
                */
            readonly high: Filter;
            /**
                * The low/mid crossover frequency.
                */
            readonly lowFrequency: Signal<Frequency>;
            /**
                * The mid/high crossover frequency.
                */
            readonly highFrequency: Signal<Frequency>;
            protected _internalChannels: Filter[];
            /**
                * The Q or Quality of the filter
                */
            readonly Q: Signal<Positive>;
            /**
                * @param lowFrequency the low/mid crossover frequency
                * @param highFrequency the mid/high crossover frequency
                */
            constructor(lowFrequency?: Frequency, highFrequency?: Frequency);
            constructor(options?: Partial<MultibandSplitOptions>);
            static getDefaults(): MultibandSplitOptions;
            /**
                * Clean up.
                */
            dispose(): this;
    }
    export {};
}

declare module 'tone/component/channel/Panner' {
    import { Param } from "tone/core/context/Param";
    import { ToneAudioNode, ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    import { AudioRange } from "tone/core/type/Units";
    interface TonePannerOptions extends ToneAudioNodeOptions {
            pan: AudioRange;
    }
    /**
        * Panner is an equal power Left/Right Panner. It is a wrapper around the StereoPannerNode.
        * @example
        * import { Oscillator, Panner } from "tone";
        * // pan the input signal hard right.
        * const panner = new Panner(1).toDestination();
        * const osc = new Oscillator().connect(panner).start();
        * @category Component
        */
    export class Panner extends ToneAudioNode<TonePannerOptions> {
            readonly name: string;
            readonly input: StereoPannerNode;
            readonly output: StereoPannerNode;
            /**
                * The pan control. -1 = hard left, 1 = hard right.
                */
            readonly pan: Param<AudioRange>;
            constructor(options?: Partial<TonePannerOptions>);
            /**
                * @param pan The initial panner value (Defaults to 0 = "center").
                */
            constructor(pan?: AudioRange);
            static getDefaults(): TonePannerOptions;
            dispose(): this;
    }
    export {};
}

declare module 'tone/component/channel/PanVol' {
    import { Param } from "tone/core/context/Param";
    import { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    import { AudioRange, Decibels } from "tone/core/type/Units";
    export interface PanVolOptions extends ToneAudioNodeOptions {
            pan: AudioRange;
            volume: Decibels;
            mute: boolean;
    }
    /**
        * PanVol is a Tone.Panner and Tone.Volume in one.
        * @example
        * // pan the incoming signal left and drop the volume
        * const panVol = new PanVol(-0.25, -12).toDestination();
        * const osc = new Oscillator().connect(panVol).start();
        * @category Component
        */
    export class PanVol extends ToneAudioNode<PanVolOptions> {
            readonly name: string;
            readonly input: InputNode;
            readonly output: OutputNode;
            /**
                * The L/R panning control.
                */
            readonly pan: Param<AudioRange>;
            /**
                * The volume control in decibels.
                */
            readonly volume: Param<Decibels>;
            /**
                * @param pan the initial pan
                * @param volume The output volume.
                */
            constructor(pan?: AudioRange, volume?: Decibels);
            constructor(options?: Partial<PanVolOptions>);
            static getDefaults(): PanVolOptions;
            /**
                * Mute/unmute the volume
                */
            mute: boolean;
            dispose(): this;
    }
}

declare module 'tone/component/channel/Volume' {
    import { Gain } from "tone/core/context/Gain";
    import { Param } from "tone/core/context/Param";
    import { ToneAudioNode, ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    import { Decibels } from "tone/core/type/Units";
    interface VolumeOptions extends ToneAudioNodeOptions {
            volume: Decibels;
            mute: boolean;
    }
    /**
        * Volume is a simple volume node, useful for creating a volume fader.
        *
        * @example
        * import { Oscillator, Volume } from "tone";
        * const vol = new Volume(-12).toDestination();
        * const osc = new Oscillator().connect(vol).start();
        * @category Component
        */
    export class Volume extends ToneAudioNode<VolumeOptions> {
            readonly name: string;
            /**
                * the output node
                */
            output: Gain<Decibels>;
            /**
                * Input and output are the same
                */
            input: Gain;
            /**
                * The volume control in decibels.
                * @example
                * import { Oscillator, Volume } from "tone";
                * const vol = new Volume().toDestination();
                * const osc = new Oscillator().connect(vol).start();
                * vol.volume.value = -20;
                */
            volume: Param<Decibels>;
            /**
                * @param volume the initial volume in decibels
                */
            constructor(volume?: Decibels);
            constructor(options?: Partial<VolumeOptions>);
            static getDefaults(): VolumeOptions;
            /**
                * Mute the output.
                * @example
                * import { Oscillator, Volume } from "tone";
                * const vol = new Volume(-12).toDestination();
                * const osc = new Oscillator().connect(vol).start();
                * // mute the output
                * vol.mute = true;
                */
            mute: boolean;
            /**
                * clean up
                */
            dispose(): this;
    }
    export {};
}

declare module 'tone/component/channel/Solo' {
    import { Gain } from "tone/core/context/Gain";
    import { ToneAudioNode, ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    export interface SoloOptions extends ToneAudioNodeOptions {
            solo: boolean;
    }
    /**
        * Solo lets you isolate a specific audio stream. When an instance is set to `solo=true`,
        * it will mute all other instances of Solo.
        * @example
        * import { Oscillator, Solo } from "tone";
        *
        * const soloA = new Solo().toDestination();
        * const oscA = new Oscillator("C4", "sawtooth").connect(soloA);
        * const soloB = new Solo().toDestination();
        * const oscB = new Oscillator("E4", "square").connect(soloB);
        *
        * soloA.solo = true;
        * // no audio will pass through soloB
        * @category Component
        */
    export class Solo extends ToneAudioNode<SoloOptions> {
            readonly name: string;
            readonly input: Gain;
            readonly output: Gain;
            /**
                * @param solo If the connection should be initially solo'ed.
                */
            constructor(solo?: boolean);
            constructor(options?: Partial<SoloOptions>);
            static getDefaults(): SoloOptions;
            /**
                * Isolates this instance and mutes all other instances of Solo.
                * Only one instance can be soloed at a time. A soloed
                * instance will report `solo=false` when another instance is soloed.
                */
            solo: boolean;
            /**
                * If the current instance is muted, i.e. another instance is soloed
                */
            readonly muted: boolean;
            dispose(): this;
    }
}

declare module 'tone/component/channel/Split' {
    import { ToneAudioNode, ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    interface SplitOptions extends ToneAudioNodeOptions {
            channels: number;
    }
    /**
        * Split splits an incoming signal into the number of given channels.
        *
        * @example
        * import { Split } from "tone";
        *
        * const split = new Split();
        * // stereoSignal.connect(split);
        * @category Component
        */
    export class Split extends ToneAudioNode<SplitOptions> {
            readonly name: string;
            readonly input: ChannelSplitterNode;
            readonly output: ChannelSplitterNode;
            /**
                * @param channels The number of channels to merge.
                */
            constructor(channels?: number);
            constructor(options?: Partial<SplitOptions>);
            static getDefaults(): SplitOptions;
            dispose(): this;
    }
    export {};
}

declare module 'tone/component/dynamics/Compressor' {
    import { Param } from "tone/core/context/Param";
    import { ToneAudioNode, ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    import { Decibels, Positive, Time } from "tone/core/type/Units";
    interface CompressorOptions extends ToneAudioNodeOptions {
            attack: Time;
            knee: Decibels;
            ratio: Positive;
            release: Time;
            threshold: Decibels;
    }
    /**
        * Compressor is a thin wrapper around the Web Audio
        * [DynamicsCompressorNode](http://webaudio.github.io/web-audio-api/#the-dynamicscompressornode-interface).
        * Compression reduces the volume of loud sounds or amplifies quiet sounds
        * by narrowing or "compressing" an audio signal's dynamic range.
        * Read more on [Wikipedia](https://en.wikipedia.org/wiki/Dynamic_range_compression).
        * @example
        * var comp = new Compressor(-30, 3);
        * @category Component
        */
    export class Compressor extends ToneAudioNode<CompressorOptions> {
            readonly name: string;
            readonly input: DynamicsCompressorNode;
            readonly output: DynamicsCompressorNode;
            /**
                * The decibel value above which the compression will start taking effect.
                * @min -100
                * @max 0
                */
            readonly threshold: Param<Decibels>;
            /**
                * The amount of time (in seconds) to reduce the gain by 10dB.
                * @min 0
                * @max 1
                */
            readonly attack: Param<Time>;
            /**
                * The amount of time (in seconds) to increase the gain by 10dB.
                * @min 0
                * @max 1
                */
            readonly release: Param<Time>;
            /**
                * A decibel value representing the range above the threshold where the
                * curve smoothly transitions to the "ratio" portion.
                * @min 0
                * @max 40
                */
            readonly knee: Param<Decibels>;
            /**
                * The amount of dB change in input for a 1 dB change in output.
                * @min 1
                * @max 20
                */
            readonly ratio: Param<Positive>;
            /**
                * @param threshold The value above which the compression starts to be applied.
                * @param ratio The gain reduction ratio.
                */
            constructor(threshold?: Decibels, ratio?: Positive);
            constructor(options?: Partial<CompressorOptions>);
            static getDefaults(): CompressorOptions;
            /**
                * A read-only decibel value for metering purposes, representing the current amount of gain
                * reduction that the compressor is applying to the signal. If fed no signal the value will be 0 (no gain reduction).
                */
            readonly reduction: number;
            dispose(): this;
    }
    export {};
}

declare module 'tone/component/envelope/AmplitudeEnvelope' {
    import { Gain } from "tone/core/context/Gain";
    import { NormalRange, Time } from "tone/core/type/Units";
    import { Envelope, EnvelopeOptions } from "tone/component/envelope/Envelope";
    /**
        * AmplitudeEnvelope is a Tone.Envelope connected to a gain node.
        * Unlike Tone.Envelope, which outputs the envelope's value, AmplitudeEnvelope accepts
        * an audio signal as the input and will apply the envelope to the amplitude
        * of the signal.
        * Read more about ADSR Envelopes on [Wikipedia](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope).
        *
        * @example
        * var ampEnv = new AmplitudeEnvelope({
        * 	attack: 0.1,
        * 	decay: 0.2,
        * 	sustain: 1.0,
        * 	release: 0.8
        * }).toDestination();
        * // create an oscillator and connect it
        * const osc = new Oscillator().connect(ampEnv).start();
        * // trigger the envelopes attack and release "8t" apart
        * ampEnv.triggerAttackRelease("8t");
        * @category Component
        */
    export class AmplitudeEnvelope extends Envelope {
            readonly name: string;
            output: Gain;
            input: Gain;
            /**
                * @param attack The amount of time it takes for the envelope to go from 0 to it's maximum value.
                * @param decay	The period of time after the attack that it takes for the envelope
                *                      	to fall to the sustain value. Value must be greater than 0.
                * @param sustain	The percent of the maximum value that the envelope rests at until
                *                               	the release is triggered.
                * @param release	The amount of time after the release is triggered it takes to reach 0.
                *                        	Value must be greater than 0.
                */
            constructor(attack?: Time, decay?: Time, sustain?: NormalRange, release?: Time);
            constructor(options?: Partial<EnvelopeOptions>);
            /**
                * Clean up
                */
            dispose(): this;
    }
}

declare module 'tone/component/envelope/Envelope' {
    import { InputNode, OutputNode } from "tone/core/context/ToneAudioNode";
    import { ToneAudioNode, ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    import { NormalRange, Time } from "tone/core/type/Units";
    import { Signal } from "tone/signal/Signal";
    type BasicEnvelopeCurve = "linear" | "exponential";
    export type EnvelopeCurve = EnvelopeCurveName | number[];
    export interface EnvelopeOptions extends ToneAudioNodeOptions {
            attack: Time;
            decay: Time;
            sustain: NormalRange;
            release: Time;
            attackCurve: EnvelopeCurve;
            releaseCurve: EnvelopeCurve;
            decayCurve: BasicEnvelopeCurve;
    }
    /**
        * Envelope is an [ADSR](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope)
        * envelope generator. Envelope outputs a signal which
        * can be connected to an AudioParam or Tone.Signal.
        * ```
        *           /\
        *          /  \
        *         /    \
        *        /      \
        *       /        \___________
        *      /                     \
        *     /                       \
        *    /                         \
        *   /                           \
        * ```
        *
        * @example
        * import { Envelope, Gain } from "tone";
        * // an amplitude envelope
        * const gainNode = new Gain();
        * const env = new Envelope({
        * 	attack: 0.1,
        * 	decay: 0.2,
        * 	sustain: 1,
        * 	release: 0.8,
        * });
        * env.connect(gainNode.gain);
        * @category Component
        */
    export class Envelope extends ToneAudioNode<EnvelopeOptions> {
            readonly name: string;
            /**
                * the signal which is output.
                */
            protected _sig: Signal<NormalRange>;
            /**
                * The output signal of the envelope
                */
            output: OutputNode;
            /**
                * Envelope has no input
                */
            input: InputNode | undefined;
            /**
                * @param attack The amount of time it takes for the envelope to go from
                *                        0 to it's maximum value.
                * @param decay	The period of time after the attack that it takes for the envelope
                *                      	to fall to the sustain value. Value must be greater than 0.
                * @param sustain	The percent of the maximum value that the envelope rests at until
                *                               	the release is triggered.
                * @param release	The amount of time after the release is triggered it takes to reach 0.
                *                        	Value must be greater than 0.
                */
            constructor(attack?: Time, decay?: Time, sustain?: NormalRange, release?: Time);
            constructor(options?: Partial<EnvelopeOptions>);
            static getDefaults(): EnvelopeOptions;
            /**
                * Read the current value of the envelope. Useful for
                * synchronizing visual output to the envelope.
                */
            readonly value: NormalRange;
            /**
                * When triggerAttack is called, the attack time is the amount of
                * time it takes for the envelope to reach it's maximum value.
                * ```
                *           /\
                *          /X \
                *         /XX  \
                *        /XXX   \
                *       /XXXX    \___________
                *      /XXXXX                \
                *     /XXXXXX                 \
                *    /XXXXXXX                  \
                *   /XXXXXXXX                   \
                * ```
                * @min 0
                * @max 2
                */
            attack: Time;
            /**
                * After the attack portion of the envelope, the value will fall
                * over the duration of the decay time to it's sustain value.
                * ```
                *           /\
                *          / X\
                *         /  XX\
                *        /   XXX\
                *       /    XXXX\___________
                *      /     XXXXX           \
                *     /      XXXXX            \
                *    /       XXXXX             \
                *   /        XXXXX              \
                * ```
                * @min 0
                * @max 2
                */
            decay: Time;
            /**
                * The sustain value is the value
                * which the envelope rests at after triggerAttack is
                * called, but before triggerRelease is invoked.
                * ```
                *           /\
                *          /  \
                *         /    \
                *        /      \
                *       /        \___________
                *      /          XXXXXXXXXXX\
                *     /           XXXXXXXXXXX \
                *    /            XXXXXXXXXXX  \
                *   /             XXXXXXXXXXX   \
                * ```
                */
            sustain: NormalRange;
            /**
                * After triggerRelease is called, the envelope's
                * value will fall to it's miminum value over the
                * duration of the release time.
                * ```
                *           /\
                *          /  \
                *         /    \
                *        /      \
                *       /        \___________
                *      /                    X\
                *     /                     XX\
                *    /                      XXX\
                *   /                       XXXX\
                * ```
                * @min 0
                * @max 5
                */
            release: Time;
            /**
                * The shape of the attack.
                * Can be any of these strings:
                * * "linear"
                * * "exponential"
                * * "sine"
                * * "cosine"
                * * "bounce"
                * * "ripple"
                * * "step"
                *
                * Can also be an array which describes the curve. Values
                * in the array are evenly subdivided and linearly
                * interpolated over the duration of the attack.
                * @example
                * env.attackCurve = "linear";
                * @example
                * // can also be an array
                * env.attackCurve = [0, 0.2, 0.3, 0.4, 1];
                */
            attackCurve: EnvelopeCurve;
            /**
                * The shape of the release. See the attack curve types.
                * @example
                * env.releaseCurve = "linear";
                */
            releaseCurve: EnvelopeCurve;
            /**
                * The shape of the decay either "linear" or "exponential"
                * @example
                * env.decayCurve = "linear";
                */
            decayCurve: BasicEnvelopeCurve;
            /**
                * Trigger the attack/decay portion of the ADSR envelope.
                * @param  time When the attack should start.
                * @param velocity The velocity of the envelope scales the vales.
                *                             number between 0-1
                * @example
                * // trigger the attack 0.5 seconds from now with a velocity of 0.2
                * env.triggerAttack("+0.5", 0.2);
                */
            triggerAttack(time?: Time, velocity?: NormalRange): this;
            /**
                * Triggers the release of the envelope.
                * @param  time When the release portion of the envelope should start.
                * @example
                * // trigger release immediately
                * env.triggerRelease();
                */
            triggerRelease(time?: Time): this;
            /**
                * Get the scheduled value at the given time. This will
                * return the unconverted (raw) value.
                */
            getValueAtTime(time: Time): NormalRange;
            /**
                * triggerAttackRelease is shorthand for triggerAttack, then waiting
                * some duration, then triggerRelease.
                * @param duration The duration of the sustain.
                * @param time When the attack should be triggered.
                * @param velocity The velocity of the envelope.
                * @example
                * // trigger the attack and then the release after 0.6 seconds.
                * env.triggerAttackRelease(0.6);
                */
            triggerAttackRelease(duration: Time, time?: Time, velocity?: NormalRange): this;
            /**
                * Cancels all scheduled envelope changes after the given time.
                */
            cancel(after?: Time): this;
            /**
                * Connect the envelope to a destination node.
                */
            connect(destination: InputNode, outputNumber?: number, inputNumber?: number): this;
            /**
                * Render the envelope curve to an array of the given length.
                * Good for visualizing the envelope curve
                */
            asArray(length?: number): Promise<Float32Array>;
            dispose(): this;
    }
    interface EnvelopeCurveObject {
            In: number[];
            Out: number[];
    }
    interface EnvelopeCurveMap {
            linear: "linear";
            exponential: "exponential";
            bounce: EnvelopeCurveObject;
            cosine: EnvelopeCurveObject;
            sine: EnvelopeCurveObject;
            ripple: EnvelopeCurveObject;
            step: EnvelopeCurveObject;
    }
    type EnvelopeCurveName = keyof EnvelopeCurveMap;
    export {};
}

declare module 'tone/component/filter/EQ3' {
    import { Gain } from "tone/core/context/Gain";
    import { Param } from "tone/core/context/Param";
    import { ToneAudioNode, ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    import { Decibels, Frequency, Positive } from "tone/core/type/Units";
    import { Signal } from "tone/signal/Signal";
    import { MultibandSplit } from "tone/component/channel/MultibandSplit";
    interface EQ3Options extends ToneAudioNodeOptions {
            low: Decibels;
            mid: Decibels;
            high: Decibels;
            lowFrequency: Frequency;
            highFrequency: Frequency;
    }
    /**
        * EQ3 provides 3 equalizer bins: Low/Mid/High.
        * @category Component
        */
    export class EQ3 extends ToneAudioNode<EQ3Options> {
            readonly name: string;
            /**
                * the input
                */
            readonly input: MultibandSplit;
            /**
                * the output
                */
            readonly output: Gain<number>;
            /**
                * The gain in decibels of the low part
                */
            readonly low: Param<Decibels>;
            /**
                * The gain in decibels of the mid part
                */
            readonly mid: Param<Decibels>;
            /**
                * The gain in decibels of the high part
                */
            readonly high: Param<Decibels>;
            /**
                * The Q value for all of the filters.
                */
            readonly Q: Signal<Positive>;
            /**
                * The low/mid crossover frequency.
                */
            readonly lowFrequency: Signal<Frequency>;
            /**
                * The mid/high crossover frequency.
                */
            readonly highFrequency: Signal<Frequency>;
            protected _internalChannels: ToneAudioNode[];
            constructor(lowLevel?: Decibels, midLevel?: Decibels, highLevel?: Decibels);
            constructor(options: Partial<EQ3Options>);
            static getDefaults(): EQ3Options;
            /**
                * Clean up.
                */
            dispose(): this;
    }
    export {};
}

declare module 'tone/component/filter/Filter' {
    import { Gain } from "tone/core/context/Gain";
    import { ToneAudioNode, ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    import { Cents, Decibels, Frequency, GainFactor, Positive } from "tone/core/type/Units";
    import { Signal } from "tone/signal/Signal";
    export type FilterRollOff = -12 | -24 | -48 | -96;
    export interface FilterOptions extends ToneAudioNodeOptions {
            type: BiquadFilterType;
            frequency: Frequency;
            rolloff: FilterRollOff;
            Q: Positive;
            detune: Cents;
            gain: GainFactor;
    }
    /**
        * Tone.Filter is a filter which allows for all of the same native methods
        * as the [BiquadFilterNode](http://webaudio.github.io/web-audio-api/#the-biquadfilternode-interface).
        * Tone.Filter has the added ability to set the filter rolloff at -12
        * (default), -24 and -48.
        * @example
        * import { Filter, Noise } from "tone";
        * const filter = new Filter(500, "highpass");
        * const noise = new Noise().connect(filter).start();
        * @category Component
        */
    export class Filter extends ToneAudioNode<FilterOptions> {
            readonly name: string;
            readonly input: Gain<number>;
            readonly output: Gain<number>;
            /**
                * The Q or Quality of the filter
                */
            readonly Q: Signal<Positive>;
            /**
                * The cutoff frequency of the filter.
                */
            readonly frequency: Signal<Frequency>;
            /**
                * The detune parameter
                */
            readonly detune: Signal<Cents>;
            /**
                * The gain of the filter, only used in certain filter types
                */
            readonly gain: Signal<Decibels>;
            /**
                * @param frequency The cutoff frequency of the filter.
                * @param type The type of filter.
                * @param rolloff The drop in decibels per octave after the cutoff frequency
                */
            constructor(frequency?: Frequency, type?: BiquadFilterType, rolloff?: FilterRollOff);
            constructor(options?: Partial<FilterOptions>);
            static getDefaults(): FilterOptions;
            /**
                * The type of the filter. Types: "lowpass", "highpass",
                * "bandpass", "lowshelf", "highshelf", "notch", "allpass", or "peaking".
                */
            type: BiquadFilterType;
            /**
                * The rolloff of the filter which is the drop in db
                * per octave. Implemented internally by cascading filters.
                * Only accepts the values -12, -24, -48 and -96.
                */
            rolloff: FilterRollOff;
            /**
                * Get the frequency response curve. This curve represents how the filter
                * responses to frequencies between 20hz-20khz.
                * @param  len The number of values to return
                * @return The frequency response curve between 20-20kHz
                */
            getFrequencyResponse(len?: number): Float32Array;
            /**
                * Clean up.
                */
            dispose(): this;
    }
}

declare module 'tone/component/filter/OnePoleFilter' {
    import { ToneAudioNode, ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    import { Frequency } from "tone/core/type/Units";
    import { Gain } from "tone/core/context/Gain";
    export type OnePoleFilterType = "highpass" | "lowpass";
    export interface OnePoleFilterOptions extends ToneAudioNodeOptions {
            frequency: Frequency;
            type: OnePoleFilterType;
    }
    /**
        * A one pole filter with 6db-per-octave rolloff. Either "highpass" or "lowpass".
        * Note that changing the type or frequency may result in a discontinuity which
        * can sound like a click or pop.
        * References:
        * * http://www.earlevel.com/main/2012/12/15/a-one-pole-filter/
        * * http://www.dspguide.com/ch19/2.htm
        * * https://github.com/vitaliy-bobrov/js-rocks/blob/master/src/app/audio/effects/one-pole-filters.ts
        * @category Component
        */
    export class OnePoleFilter extends ToneAudioNode<OnePoleFilterOptions> {
            readonly name: string;
            readonly input: Gain;
            readonly output: Gain;
            /**
                * @param frequency The frequency
                * @param type The  filter type, either "lowpass" or "highpass"
                */
            constructor(frequency?: Frequency, type?: OnePoleFilterType);
            constructor(options?: Partial<OnePoleFilterOptions>);
            static getDefaults(): OnePoleFilterOptions;
            /**
                * The frequency value.
                */
            frequency: Frequency;
            /**
                * The OnePole Filter type, either "highpass" or "lowpass"
                */
            type: OnePoleFilterType;
            /**
                * Get the frequency response curve. This curve represents how the filter
                * responses to frequencies between 20hz-20khz.
                * @param  len The number of values to return
                * @return The frequency response curve between 20-20kHz
                */
            getFrequencyResponse(len?: number): Float32Array;
            dispose(): this;
    }
}

declare module 'tone/component/filter/FeedbackCombFilter' {
    import { Gain } from "tone/core/context/Gain";
    import { Param } from "tone/core/context/Param";
    import { ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    import { NormalRange, Time } from "tone/core/type/Units";
    import { RecursivePartial } from "tone/core/util/Interface";
    import { ToneAudioWorklet } from "tone/core/context/ToneAudioWorklet";
    export interface FeedbackCombFilterOptions extends ToneAudioNodeOptions {
            delayTime: Time;
            resonance: NormalRange;
    }
    /**
        * Comb filters are basic building blocks for physical modeling. Read more
        * about comb filters on [CCRMA's website](https://ccrma.stanford.edu/~jos/pasp/Feedback_Comb_Filters.html).
        *
        * This comb filter is implemented with the AudioWorkletNode which allows it to have feedback delays less than the
        * Web Audio processing block of 128 samples. There is a polyfill for browsers that don't yet support the
        * AudioWorkletNode, but it will add some latency and have slower performance than the AudioWorkletNode.
        * @category Component
        */
    export class FeedbackCombFilter extends ToneAudioWorklet<FeedbackCombFilterOptions> {
            readonly name = "FeedbackCombFilter";
            /**
                * The amount of delay of the comb filter.
                */
            readonly delayTime: Param<Time>;
            /**
                * The amount of feedback of the delayed signal.
                */
            readonly resonance: Param<NormalRange>;
            readonly input: Gain;
            readonly output: Gain;
            /**
                * Default constructor options for the filter
                */
            protected workletOptions: Partial<AudioWorkletNodeOptions>;
            /**
                * @param delayTime The delay time of the filter.
                * @param resonance The amount of feedback the filter has.
                */
            constructor(delayTime?: Time, resonance?: NormalRange);
            constructor(options?: RecursivePartial<FeedbackCombFilterOptions>);
            protected _audioWorkletName(): string;
            protected _audioWorklet(): string;
            /**
                * The default parameters
                */
            static getDefaults(): FeedbackCombFilterOptions;
            onReady(node: AudioWorkletNode): void;
            dispose(): this;
    }
}

declare module 'tone/component/filter/LowpassCombFilter' {
    import { Param } from "tone/core/context/Param";
    import { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    import { Frequency, NormalRange, Time } from "tone/core/type/Units";
    import { RecursivePartial } from "tone/core/util/Interface";
    interface LowpassCombFilterOptions extends ToneAudioNodeOptions {
            delayTime: Time;
            resonance: NormalRange;
            dampening: Frequency;
    }
    /**
        * A lowpass feedback comb filter. It is similar to
        * [[FeedbackCombFilter]], but includes a lowpass filter.
        * @category Component
        */
    export class LowpassCombFilter extends ToneAudioNode<LowpassCombFilterOptions> {
            readonly name = "LowpassCombFilter";
            /**
                * The delayTime of the comb filter.
                */
            readonly delayTime: Param<Time>;
            /**
                * The amount of feedback of the delayed signal.
                */
            readonly resonance: Param<NormalRange>;
            readonly input: InputNode;
            readonly output: OutputNode;
            /**
                * @param delayTime The delay time of the comb filter
                * @param resonance The resonance (feedback) of the comb filter
                * @param dampening The cutoff of the lowpass filter dampens the signal as it is fedback.
                */
            constructor(delayTime?: Time, resonance?: NormalRange, dampening?: Frequency);
            constructor(options?: RecursivePartial<LowpassCombFilterOptions>);
            static getDefaults(): LowpassCombFilterOptions;
            /**
                * The dampening control of the feedback
                */
            dampening: Frequency;
            dispose(): this;
    }
    export {};
}

declare module 'tone/component/filter/Convolver' {
    import { ToneAudioNode, ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    import { ToneAudioBuffer } from "tone/core/context/ToneAudioBuffer";
    import { Gain } from "tone/core/context/Gain";
    export interface ConvolverOptions extends ToneAudioNodeOptions {
            onload: () => void;
            normalize: boolean;
            url?: string | AudioBuffer | ToneAudioBuffer;
    }
    /**
        * Convolver is a wrapper around the Native Web Audio
        * [ConvolverNode](http://webaudio.github.io/web-audio-api/#the-convolvernode-interface).
        * Convolution is useful for reverb and filter emulation. Read more about convolution reverb on
        * [Wikipedia](https://en.wikipedia.org/wiki/Convolution_reverb).
        *
        * @example
        * //initializing the convolver with an impulse response
        * var convolver = new Convolver("./path/to/ir.wav").toDestination();
        * @category Component
        */
    export class Convolver extends ToneAudioNode<ConvolverOptions> {
            readonly name: string;
            readonly input: Gain;
            readonly output: Gain;
            /**
                * @param url The URL of the impulse response or the ToneAudioBuffer containing the impulse response.
                * @param onload The callback to invoke when the url is loaded.
                */
            constructor(url?: string | AudioBuffer | ToneAudioBuffer, onload?: () => void);
            constructor(options?: Partial<ConvolverOptions>);
            static getDefaults(): ConvolverOptions;
            /**
                * Load an impulse response url as an audio buffer.
                * Decodes the audio asynchronously and invokes
                * the callback once the audio buffer loads.
                * @param url The url of the buffer to load. filetype support depends on the browser.
                */
            load(url: string): Promise<void>;
            /**
                * The convolver's buffer
                */
            buffer: ToneAudioBuffer | null;
            /**
                * The normalize property of the ConvolverNode interface is a boolean that
                * controls whether the impulse response from the buffer will be scaled by
                * an equal-power normalization when the buffer attribute is set, or not.
                */
            normalize: boolean;
            dispose(): this;
    }
}

declare module 'tone/core/type/NoteUnits' {
    /**
        * A note in Scientific pitch notation.
        * The pitch class + octave number
        * e.g. "C4", "D#3", "G-1"
        * @category Unit
        */
    export type Note = "Cbb-4" | "Cb-4" | "C-4" | "C#-4" | "Cx-4" | "Dbb-4" | "Db-4" | "D-4" | "D#-4" | "Dx-4" | "Ebb-4" | "Eb-4" | "E-4" | "E#-4" | "Ex-4" | "Fbb-4" | "Fb-4" | "F-4" | "F#-4" | "Fx-4" | "Gbb-4" | "Gb-4" | "G-4" | "G#-4" | "Gx-4" | "Abb-4" | "Ab-4" | "A-4" | "A#-4" | "Ax-4" | "Bbb-4" | "Bb-4" | "B-4" | "B#-4" | "Bx-4" | "Cbb-3" | "Cb-3" | "C-3" | "C#-3" | "Cx-3" | "Dbb-3" | "Db-3" | "D-3" | "D#-3" | "Dx-3" | "Ebb-3" | "Eb-3" | "E-3" | "E#-3" | "Ex-3" | "Fbb-3" | "Fb-3" | "F-3" | "F#-3" | "Fx-3" | "Gbb-3" | "Gb-3" | "G-3" | "G#-3" | "Gx-3" | "Abb-3" | "Ab-3" | "A-3" | "A#-3" | "Ax-3" | "Bbb-3" | "Bb-3" | "B-3" | "B#-3" | "Bx-3" | "Cbb-2" | "Cb-2" | "C-2" | "C#-2" | "Cx-2" | "Dbb-2" | "Db-2" | "D-2" | "D#-2" | "Dx-2" | "Ebb-2" | "Eb-2" | "E-2" | "E#-2" | "Ex-2" | "Fbb-2" | "Fb-2" | "F-2" | "F#-2" | "Fx-2" | "Gbb-2" | "Gb-2" | "G-2" | "G#-2" | "Gx-2" | "Abb-2" | "Ab-2" | "A-2" | "A#-2" | "Ax-2" | "Bbb-2" | "Bb-2" | "B-2" | "B#-2" | "Bx-2" | "Cbb-1" | "Cb-1" | "C-1" | "C#-1" | "Cx-1" | "Dbb-1" | "Db-1" | "D-1" | "D#-1" | "Dx-1" | "Ebb-1" | "Eb-1" | "E-1" | "E#-1" | "Ex-1" | "Fbb-1" | "Fb-1" | "F-1" | "F#-1" | "Fx-1" | "Gbb-1" | "Gb-1" | "G-1" | "G#-1" | "Gx-1" | "Abb-1" | "Ab-1" | "A-1" | "A#-1" | "Ax-1" | "Bbb-1" | "Bb-1" | "B-1" | "B#-1" | "Bx-1" | "Cbb0" | "Cb0" | "C0" | "C#0" | "Cx0" | "Dbb0" | "Db0" | "D0" | "D#0" | "Dx0" | "Ebb0" | "Eb0" | "E0" | "E#0" | "Ex0" | "Fbb0" | "Fb0" | "F0" | "F#0" | "Fx0" | "Gbb0" | "Gb0" | "G0" | "G#0" | "Gx0" | "Abb0" | "Ab0" | "A0" | "A#0" | "Ax0" | "Bbb0" | "Bb0" | "B0" | "B#0" | "Bx0" | "Cbb1" | "Cb1" | "C1" | "C#1" | "Cx1" | "Dbb1" | "Db1" | "D1" | "D#1" | "Dx1" | "Ebb1" | "Eb1" | "E1" | "E#1" | "Ex1" | "Fbb1" | "Fb1" | "F1" | "F#1" | "Fx1" | "Gbb1" | "Gb1" | "G1" | "G#1" | "Gx1" | "Abb1" | "Ab1" | "A1" | "A#1" | "Ax1" | "Bbb1" | "Bb1" | "B1" | "B#1" | "Bx1" | "Cbb2" | "Cb2" | "C2" | "C#2" | "Cx2" | "Dbb2" | "Db2" | "D2" | "D#2" | "Dx2" | "Ebb2" | "Eb2" | "E2" | "E#2" | "Ex2" | "Fbb2" | "Fb2" | "F2" | "F#2" | "Fx2" | "Gbb2" | "Gb2" | "G2" | "G#2" | "Gx2" | "Abb2" | "Ab2" | "A2" | "A#2" | "Ax2" | "Bbb2" | "Bb2" | "B2" | "B#2" | "Bx2" | "Cbb3" | "Cb3" | "C3" | "C#3" | "Cx3" | "Dbb3" | "Db3" | "D3" | "D#3" | "Dx3" | "Ebb3" | "Eb3" | "E3" | "E#3" | "Ex3" | "Fbb3" | "Fb3" | "F3" | "F#3" | "Fx3" | "Gbb3" | "Gb3" | "G3" | "G#3" | "Gx3" | "Abb3" | "Ab3" | "A3" | "A#3" | "Ax3" | "Bbb3" | "Bb3" | "B3" | "B#3" | "Bx3" | "Cbb4" | "Cb4" | "C4" | "C#4" | "Cx4" | "Dbb4" | "Db4" | "D4" | "D#4" | "Dx4" | "Ebb4" | "Eb4" | "E4" | "E#4" | "Ex4" | "Fbb4" | "Fb4" | "F4" | "F#4" | "Fx4" | "Gbb4" | "Gb4" | "G4" | "G#4" | "Gx4" | "Abb4" | "Ab4" | "A4" | "A#4" | "Ax4" | "Bbb4" | "Bb4" | "B4" | "B#4" | "Bx4" | "Cbb5" | "Cb5" | "C5" | "C#5" | "Cx5" | "Dbb5" | "Db5" | "D5" | "D#5" | "Dx5" | "Ebb5" | "Eb5" | "E5" | "E#5" | "Ex5" | "Fbb5" | "Fb5" | "F5" | "F#5" | "Fx5" | "Gbb5" | "Gb5" | "G5" | "G#5" | "Gx5" | "Abb5" | "Ab5" | "A5" | "A#5" | "Ax5" | "Bbb5" | "Bb5" | "B5" | "B#5" | "Bx5" | "Cbb6" | "Cb6" | "C6" | "C#6" | "Cx6" | "Dbb6" | "Db6" | "D6" | "D#6" | "Dx6" | "Ebb6" | "Eb6" | "E6" | "E#6" | "Ex6" | "Fbb6" | "Fb6" | "F6" | "F#6" | "Fx6" | "Gbb6" | "Gb6" | "G6" | "G#6" | "Gx6" | "Abb6" | "Ab6" | "A6" | "A#6" | "Ax6" | "Bbb6" | "Bb6" | "B6" | "B#6" | "Bx6" | "Cbb7" | "Cb7" | "C7" | "C#7" | "Cx7" | "Dbb7" | "Db7" | "D7" | "D#7" | "Dx7" | "Ebb7" | "Eb7" | "E7" | "E#7" | "Ex7" | "Fbb7" | "Fb7" | "F7" | "F#7" | "Fx7" | "Gbb7" | "Gb7" | "G7" | "G#7" | "Gx7" | "Abb7" | "Ab7" | "A7" | "A#7" | "Ax7" | "Bbb7" | "Bb7" | "B7" | "B#7" | "Bx7" | "Cbb8" | "Cb8" | "C8" | "C#8" | "Cx8" | "Dbb8" | "Db8" | "D8" | "D#8" | "Dx8" | "Ebb8" | "Eb8" | "E8" | "E#8" | "Ex8" | "Fbb8" | "Fb8" | "F8" | "F#8" | "Fx8" | "Gbb8" | "Gb8" | "G8" | "G#8" | "Gx8" | "Abb8" | "Ab8" | "A8" | "A#8" | "Ax8" | "Bbb8" | "Bb8" | "B8" | "B#8" | "Bx8" | "Cbb9" | "Cb9" | "C9" | "C#9" | "Cx9" | "Dbb9" | "Db9" | "D9" | "D#9" | "Dx9" | "Ebb9" | "Eb9" | "E9" | "E#9" | "Ex9" | "Fbb9" | "Fb9" | "F9" | "F#9" | "Fx9" | "Gbb9" | "Gb9" | "G9" | "G#9" | "Gx9" | "Abb9" | "Ab9" | "A9" | "A#9" | "Ax9" | "Bbb9" | "Bb9" | "B9" | "B#9" | "Bx9" | "Cbb10" | "Cb10" | "C10" | "C#10" | "Cx10" | "Dbb10" | "Db10" | "D10" | "D#10" | "Dx10" | "Ebb10" | "Eb10" | "E10" | "E#10" | "Ex10" | "Fbb10" | "Fb10" | "F10" | "F#10" | "Fx10" | "Gbb10" | "Gb10" | "G10" | "G#10" | "Gx10" | "Abb10" | "Ab10" | "A10" | "A#10" | "Ax10" | "Bbb10" | "Bb10" | "B10" | "B#10" | "Bx10" | "Cbb11" | "Cb11" | "C11" | "C#11" | "Cx11" | "Dbb11" | "Db11" | "D11" | "D#11" | "Dx11" | "Ebb11" | "Eb11" | "E11" | "E#11" | "Ex11" | "Fbb11" | "Fb11" | "F11" | "F#11" | "Fx11" | "Gbb11" | "Gb11" | "G11" | "G#11" | "Gx11" | "Abb11" | "Ab11" | "A11" | "A#11" | "Ax11" | "Bbb11" | "Bb11" | "B11" | "B#11" | "Bx11";
    /**
        * A number representing a midi note. Integers between 0-127
        * @category Unit
        */
    export type MidiNote = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 32 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 | 91 | 92 | 93 | 94 | 95 | 96 | 97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 123 | 124 | 125 | 126 | 127;
}

declare module 'tone/core/context/ToneWithContext' {
    import { Tone } from "tone/core/Tone";
    import { TimeClass } from "tone/core/type/Time";
    import { Frequency, Hertz, Seconds, Ticks, Time } from "tone/core/type/Units";
    import { RecursivePartial } from "tone/core/util/Interface";
    import { Context } from "tone/core/context/Context";
    /**
        * A unit which process audio
        */
    export interface ToneWithContextOptions {
            context: Context;
    }
    /**
        * The Base class for all nodes that have an AudioContext.
        */
    export abstract class ToneWithContext<Options extends ToneWithContextOptions> extends Tone {
            /**
                * The context belonging to the node.
                */
            readonly context: Context;
            /**
                * The default context to use if no AudioContext is passed in to the constructor.
                * Probably should not be set manually. Used internally.
                * @hidden
                */
            readonly defaultContext?: Context;
            /**
                * Pass in a constructor as the first argument
                */
            constructor(context?: Context);
            constructor(options?: Partial<ToneWithContextOptions>);
            static getDefaults(): ToneWithContextOptions;
            /**
                * Return the current time of the Context clock plus the lookAhead.
                */
            now(): Seconds;
            /**
                * Return the current time of the Context clock without any lookAhead.
                */
            immediate(): Seconds;
            /**
                * The duration in seconds of one sample.
                */
            readonly sampleTime: Seconds;
            /**
                * The number of seconds of 1 processing block (128 samples)
                */
            readonly blockTime: Seconds;
            /**
                * Convert the incoming time to seconds
                */
            toSeconds(time?: Time): Seconds;
            /**
                * Convert the input to a frequency number
                */
            toFrequency(freq: Frequency): Hertz;
            /**
                * Convert the input time into ticks
                */
            toTicks(time?: Time | TimeClass): Ticks;
            /**
                * Get a subset of the properties which are in the partial props
                */
            protected _getPartialProperties(props: Options): Partial<Options>;
            /**
                * Get the object's attributes.
                * @example
                * osc.get();
                * //returns {"type" : "sine", "frequency" : 440, ...etc}
                */
            get(): Options;
            /**
                * Set multiple properties at once with an object.
                * @param  props
                * @example
                * //set values using an object
                * filter.set({
                * 	"frequency" : 300,
                * 	"type" : "highpass"
                * });
                */
            set(props: RecursivePartial<Options>): this;
    }
}

declare module 'tone/core/context/AbstractParam' {
    import { Time, Unit, UnitName } from "tone/core/type/Units";
    /**
        * Abstract base class for [[Param]] and [[Signal]]
        */
    export abstract class AbstractParam<Type extends Unit> {
            /**
                * Schedules a parameter value change at the given time.
                * Does this work? is this working. are you working?
                * @param value The value to set the signal.
                * @param time The time when the change should occur.
                * @example
                * //set the frequency to "G4" in exactly 1 second from now.
                * freq.setValueAtTime("G4", "+1");
                */
            abstract setValueAtTime(value: Type, time: Time): this;
            /**
                * Get the signals value at the given time. Subsequent scheduling
                * may invalidate the returned value.
                * @param time When to get the value
                */
            abstract getValueAtTime(time: Time): Type;
            /**
                * Creates a schedule point with the current value at the current time.
                * This is useful for creating an automation anchor point in order to
                * schedule changes from the current value.
                * @param time When to add a ramp point.
                * @example
                * param.getValueAtTime(Tone.now())
                */
            abstract setRampPoint(time: Time): this;
            /**
                * Schedules a linear continuous change in parameter value from the
                * previous scheduled parameter value to the given value.
                */
            abstract linearRampToValueAtTime(value: Type, time: Time): this;
            /**
                * Schedules an exponential continuous change in parameter value from
                * the previous scheduled parameter value to the given value.
                */
            abstract exponentialRampToValueAtTime(value: Type, time: Time): this;
            /**
                * Schedules an exponential continuous change in parameter value from
                * the current time and current value to the given value over the
                * duration of the rampTime.
                * @param value   The value to ramp to.
                * @param rampTime the time that it takes the
                *                             value to ramp from it's current value
                * @param startTime When the ramp should start.
                * @example
                * //exponentially ramp to the value 2 over 4 seconds.
                * signal.exponentialRampTo(2, 4);
                */
            abstract exponentialRampTo(value: Type, rampTime: Time, startTime?: Time): this;
            /**
                * Schedules an linear continuous change in parameter value from
                * the current time and current value to the given value over the
                * duration of the rampTime.
                *
                * @param  value   The value to ramp to.
                * @param  rampTime the time that it takes the
                *                              value to ramp from it's current value
                * @param startTime 	When the ramp should start.
                * @returns {Param} this
                * @example
                * //linearly ramp to the value 4 over 3 seconds.
                * signal.linearRampTo(4, 3);
                */
            abstract linearRampTo(value: Type, rampTime: Time, startTime?: Time): this;
            /**
                * Start exponentially approaching the target value at the given time. Since it
                * is an exponential approach it will continue approaching after the ramp duration. The
                * rampTime is the time that it takes to reach over 99% of the way towards the value.
                * @param  value   The value to ramp to.
                * @param  rampTime the time that it takes the
                *                              value to ramp from it's current value
                * @param startTime 	When the ramp should start.
                * @example
                * //exponentially ramp to the value 2 over 4 seconds.
                * signal.exponentialRampTo(2, 4);
                */
            abstract targetRampTo(value: Type, rampTime: Time, startTime?: Time): this;
            /**
                * Start exponentially approaching the target value at the given time. Since it
                * is an exponential approach it will continue approaching after the ramp duration. The
                * rampTime is the time that it takes to reach over 99% of the way towards the value. This methods
                * is similar to setTargetAtTime except the third argument is a time instead of a 'timeConstant'
                * @param  value   The value to ramp to.
                * @param time 	When the ramp should start.
                * @param  rampTime the time that it takes the value to ramp from it's current value
                * @example
                * //exponentially ramp to the value 2 over 4 seconds.
                * signal.exponentialRampTo(2, 4);
                */
            abstract exponentialApproachValueAtTime(value: Type, time: Time, rampTime: Time): this;
            /**
                * Start exponentially approaching the target value at the given time with
                * a rate having the given time constant.
                * @param value
                * @param startTime
                * @param timeConstant
                */
            abstract setTargetAtTime(value: Type, startTime: Time, timeConstant: number): this;
            /**
                * Sets an array of arbitrary parameter values starting at the given time
                * for the given duration.
                *
                * @param values
                * @param startTime
                * @param duration
                * @param scaling If the values in the curve should be scaled by some value
                */
            abstract setValueCurveAtTime(values: Type[], startTime: Time, duration: Time, scaling?: number): this;
            /**
                * Cancels all scheduled parameter changes with times greater than or
                * equal to startTime.
                */
            abstract cancelScheduledValues(time: Time): this;
            /**
                * This is similar to [[cancelScheduledValues]] except
                * it holds the automated value at time until the next automated event.
                */
            abstract cancelAndHoldAtTime(time: Time): this;
            /**
                * Ramps to the given value over the duration of the rampTime.
                * Automatically selects the best ramp type (exponential or linear)
                * depending on the `units` of the signal
                *
                * @param  value
                * @param  rampTime The time that it takes the value to ramp from it's current value
                * @param startTime When the ramp should start.
                * @example
                * //ramp to the value either linearly or exponentially
                * //depending on the "units" value of the signal
                * signal.rampTo(0, 10);
                * @example
                * //schedule it to ramp starting at a specific time
                * signal.rampTo(0, 10, 5)
                */
            abstract rampTo(value: Type, rampTime: Time, startTime?: Time): this;
            /**
                * The current value of the parameter. Setting this value
                * is equivalent to setValueAtTime(value, context.currentTime)
                */
            abstract value: Type;
            /**
                * If the value should be converted or not
                */
            abstract convert: boolean;
            /**
                * The unit type
                */
            abstract readonly units: UnitName;
            /**
                * True if the signal value is being overridden by
                * a connected signal. Internal use only.
                */
            abstract overridden: boolean;
            /**
                * The minimum value of the output given the units
                */
            abstract readonly minValue: number;
            /**
                * The maximum value of the output given the units
                */
            abstract readonly maxValue: number;
    }
}

declare module 'tone/core/clock/TickSignal' {
    import { Signal, SignalOptions } from "tone/signal/Signal";
    import { InputNode } from "tone/core/context/ToneAudioNode";
    import { BPM, Hertz, Seconds, Ticks, Time } from "tone/core/type/Units";
    import { TickParam } from "tone/core/clock/TickParam";
    interface TickSignalOptions<T> extends SignalOptions<T> {
            value: T;
            multiplier: number;
    }
    /**
        * TickSignal extends Tone.Signal, but adds the capability
        * to calculate the number of elapsed ticks. exponential and target curves
        * are approximated with multiple linear ramps.
        *
        * Thank you Bruno Dias, H. Sofia Pinto, and David M. Matos,
        * for your [WAC paper](https://smartech.gatech.edu/bitstream/handle/1853/54588/WAC2016-49.pdf)
        * describing integrating timing functions for tempo calculations.
        */
    export class TickSignal<Type extends Hertz | BPM> extends Signal<Type> {
            readonly name: string;
            /**
                * The param which controls the output signal value
                */
            protected _param: TickParam<Type>;
            readonly input: InputNode;
            /**
                * @param value The initial value of the signal
                */
            constructor(value?: Type);
            constructor(options: Partial<TickSignalOptions<Type>>);
            static getDefaults(): TickSignalOptions<any>;
            ticksToTime(ticks: Ticks, when: Time): Seconds;
            timeToTicks(duration: Time, when: Time): Ticks;
            getTimeOfTick(tick: Ticks): Seconds;
            getDurationOfTicks(ticks: Ticks, time: Time): Seconds;
            getTicksAtTime(time: Time): Ticks;
            /**
                * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.
                */
            multiplier: number;
            dispose(): this;
    }
    export {};
}

declare module 'tone/core/type/TimeBase' {
    import { Context } from "tone/core/context/Context";
    import { Tone } from "tone/core/Tone";
    import { BPM, Hertz, MidiNote, Milliseconds, Samples, Seconds, Ticks, Time } from "tone/core/type/Units";
    export type TimeValue = Time | TimeBaseClass<any, any>;
    /**
        * The units that the TimeBase can accept. extended by other classes
        */
    export type TimeBaseUnit = "s" | "n" | "t" | "m" | "i" | "hz" | "tr" | "samples" | "number";
    export interface TypeFunction {
            regexp: RegExp;
            method: (value: string, ...args: string[]) => number;
    }
    export interface TimeExpression<Type extends number> {
            [key: string]: {
                    regexp: RegExp;
                    method: (value: string, ...args: string[]) => Type;
            };
    }
    /**
        * TimeBase is a flexible encoding of time which can be evaluated to and from a string.
        * @example
        * new TimeBase(4, "n")
        * new TimeBase(2, "t")
        * new TimeBase("2t")
        * new TimeBase({"2t" : 2})
        * new TimeBase("2t") + new TimeBase("4n");
        */
    export abstract class TimeBaseClass<Type extends number, Unit extends string> extends Tone {
            readonly context: Context;
            /**
                * The value of the units
                */
            protected _val?: TimeValue;
            /**
                * The units of time
                */
            protected _units?: Unit;
            /**
                * All of the conversion expressions
                */
            protected _expressions: TimeExpression<Type>;
            /**
                * The default units
                */
            readonly defaultUnits: Unit;
            /**
                * @param context The context associated with the time value. Used to compute
                * Transport and context-relative timing.
                * @param  value  The time value as a number, string or object
                * @param  units  Unit values
                */
            constructor(context: Context, value?: TimeValue, units?: Unit);
            /**
                * All of the time encoding expressions
                */
            protected _getExpressions(): TimeExpression<Type>;
            /**
                * Evaluate the time value. Returns the time in seconds.
                */
            valueOf(): Type;
            /**
                * Returns the value of a frequency in the current units
                */
            protected _frequencyToUnits(freq: Hertz): Type;
            /**
                * Return the value of the beats in the current units
                */
            protected _beatsToUnits(beats: number): Type;
            /**
                * Returns the value of a second in the current units
                */
            protected _secondsToUnits(seconds: Seconds): Type;
            /**
                * Returns the value of a tick in the current time units
                */
            protected _ticksToUnits(ticks: Ticks): Type;
            /**
                * With no arguments, return 'now'
                */
            protected _noArg(): Type;
            /**
                * Return the bpm
                */
            protected _getBpm(): BPM;
            /**
                * Return the timeSignature
                */
            protected _getTimeSignature(): number;
            /**
                * Return the PPQ or 192 if Transport is not available
                */
            protected _getPPQ(): number;
            /**
                * Return the current time in whichever context is relevant
                */
            protected abstract _now(): Type;
            /**
                * Coerce a time type into this units type.
                * @param type Any time type units
                */
            fromType(type: TimeBaseClass<any, any>): this;
            /**
                * Return the value in seconds
                */
            abstract toSeconds(): Seconds;
            /**
                * Return the value as a Midi note
                */
            abstract toMidi(): MidiNote;
            /**
                * Convert the value into ticks
                */
            abstract toTicks(): Ticks;
            /**
                * Return the value in hertz
                */
            toFrequency(): Hertz;
            /**
                * Return the time in samples
                */
            toSamples(): Samples;
            /**
                * Return the time in milliseconds.
                */
            toMilliseconds(): Milliseconds;
    }
}

declare module 'tone/core/clock/TickParam' {
    import { AutomationEvent, Param, ParamOptions } from "tone/core/context/Param";
    import { BPM, Hertz, Seconds, Ticks, Time } from "tone/core/type/Units";
    import { Timeline } from "tone/core/util/Timeline";
    type TickAutomationEvent = AutomationEvent & {
            ticks: number;
    };
    interface TickParamOptions<Type> extends ParamOptions<Type> {
            multiplier: number;
    }
    /**
        * A Param class just for computing ticks. Similar to the [[Param]] class,
        * but offers conversion to BPM values as well as ability to compute tick
        * duration and elapsed ticks
        */
    export class TickParam<Type extends Hertz | BPM> extends Param<Type> {
            readonly name: string;
            /**
                * The timeline which tracks all of the automations.
                */
            protected _events: Timeline<TickAutomationEvent>;
            /**
                * @param value The initial value of the signal
                */
            constructor(value?: number);
            constructor(options: Partial<TickParamOptions<Type>>);
            static getDefaults(): TickParamOptions<any>;
            setTargetAtTime(value: Type, time: Time, constant: number): this;
            setValueAtTime(value: Type, time: Time): this;
            linearRampToValueAtTime(value: Type, time: Time): this;
            exponentialRampToValueAtTime(value: Type, time: Time): this;
            /**
                * Returns the tick value at the time. Takes into account
                * any automation curves scheduled on the signal.
                * @param  time The time to get the tick count at
                * @return The number of ticks which have elapsed at the time given any automations.
                */
            getTicksAtTime(time: Time): Ticks;
            /**
                * Return the elapsed time of the number of ticks from the given time
                * @param ticks The number of ticks to calculate
                * @param  time The time to get the next tick from
                * @return The duration of the number of ticks from the given time in seconds
                */
            getDurationOfTicks(ticks: Ticks, time: Time): Seconds;
            /**
                * Given a tick, returns the time that tick occurs at.
                * @return The time that the tick occurs.
                */
            getTimeOfTick(tick: Ticks): Seconds;
            /**
                * Convert some number of ticks their the duration in seconds accounting
                * for any automation curves starting at the given time.
                * @param  ticks The number of ticks to convert to seconds.
                * @param  when  When along the automation timeline to convert the ticks.
                * @return The duration in seconds of the ticks.
                */
            ticksToTime(ticks: Ticks, when: Time): Seconds;
            /**
                * The inverse of [[ticksToTime]]. Convert a duration in
                * seconds to the corresponding number of ticks accounting for any
                * automation curves starting at the given time.
                * @param  duration The time interval to convert to ticks.
                * @param  when When along the automation timeline to convert the ticks.
                * @return The duration in ticks.
                */
            timeToTicks(duration: Time, when: Time): Ticks;
            /**
                * Convert from the type when the unit value is BPM
                */
            protected _fromType(val: Type): number;
            /**
                * Special case of type conversion where the units === "bpm"
                */
            protected _toType(val: number): Type;
            /**
                * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.
                */
            multiplier: number;
    }
    export {};
}

declare module 'tone/source/Source' {
    import "../core/context/Destination";
    import "../core/clock/Transport";
    import { Param } from "tone/core/context/Param";
    import { OutputNode, ToneAudioNode, ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    import { Decibels, Seconds, Time } from "tone/core/type/Units";
    import { BasicPlaybackState, StateTimeline } from "tone/core/util/StateTimeline";
    type onStopCallback = (source: Source<any>) => void;
    export interface SourceOptions extends ToneAudioNodeOptions {
            volume: Decibels;
            mute: boolean;
            onstop: onStopCallback;
    }
    /**
        * Base class for sources. Sources have start/stop methods
        * and the ability to be synced to the
        * start/stop of this.context.transport.
        *
        * @example
        * //Multiple state change events can be chained together,
        * //but must be set in the correct order and with ascending times
        *
        * // OK
        * state.start().stop("+0.2");
        * // AND
        * state.start().stop("+0.2").start("+0.4").stop("+0.7")
        *
        * // BAD
        * state.stop("+0.2").start();
        * // OR
        * state.start("+0.3").stop("+0.2");
        *
        */
    export abstract class Source<Options extends SourceOptions> extends ToneAudioNode<Options> {
            /**
                * The output note
                */
            output: OutputNode;
            /**
                * Sources have no inputs
                */
            input: undefined;
            /**
                * The volume of the output in decibels.
                * @example
                * source.volume.value = -6;
                */
            volume: Param<Decibels>;
            /**
                * The callback to invoke when the source is stopped.
                */
            onstop: onStopCallback;
            /**
                * Keep track of the scheduled state.
                */
            protected _state: StateTimeline<{
                    duration?: Seconds;
                    offset?: Seconds;
                    /**
                        * Either the buffer is explicitly scheduled to end using the stop method,
                        * or it's implicitly ended when the buffer is over.
                        */
                    implicitEnd?: boolean;
            }>;
            /**
                * The synced `start` callback function from the transport
                */
            protected _synced: boolean;
            constructor(options: SourceOptions);
            static getDefaults(): SourceOptions;
            /**
                * Returns the playback state of the source, either "started" or "stopped".
                */
            readonly state: BasicPlaybackState;
            /**
                * Mute the output.
                * @example
                * //mute the output
                * source.mute = true;
                */
            mute: boolean;
            protected abstract _start(time: Time, offset?: Time, duration?: Time): void;
            protected abstract _stop(time: Time): void;
            abstract restart(time: Time, offset?: Time, duration?: Time): this;
            /**
                * Start the source at the specified time. If no time is given,
                * start the source now.
                * @param  time When the source should be started.
                * @example
                * source.start("+0.5"); //starts the source 0.5 seconds from now
                */
            start(time?: Time, offset?: Time, duration?: Time): this;
            /**
                * Stop the source at the specified time. If no time is given,
                * stop the source now.
                * @param  time When the source should be stopped.
                * @example
                * source.stop(); // stops the source immediately
                */
            stop(time?: Time): this;
            /**
                * Sync the source to the Transport so that all subsequent
                * calls to `start` and `stop` are synced to the TransportTime
                * instead of the AudioContext time.
                *
                * @example
                * //sync the source so that it plays between 0 and 0.3 on the Transport's timeline
                * source.sync().start(0).stop(0.3);
                * //start the transport.
                * this.context.transport.start();
                *
                * @example
                * //start the transport with an offset and the sync'ed sources
                * //will start in the correct position
                * source.sync().start(0.1);
                * //the source will be invoked with an offset of 0.4 = (0.5 - 0.1)
                * this.context.transport.start("+0.5", 0.5);
                */
            sync(): this;
            /**
                * Unsync the source to the Transport. See Source.sync
                */
            unsync(): this;
            /**
                * Clean up.
                */
            dispose(): this;
    }
    export {};
}

declare module 'tone/source/oscillator/OscillatorInterface' {
    import { AudioRange, Cents, Degrees, Frequency, Positive } from "tone/core/type/Units";
    import { Omit } from "tone/core/util/Interface";
    import { Signal } from "tone/signal/Signal";
    import { SourceOptions } from "tone/source/Source";
    /**
        * The common interface of all Oscillators
        */
    export interface ToneOscillatorInterface {
            baseType: OscillatorType | "pulse" | "pwm";
            type: ExtendedToneOscillatorType;
            readonly frequency: Signal<Frequency>;
            readonly detune: Signal<Cents>;
            phase: Degrees;
            partials: number[];
            partialCount?: number;
            /**
                * Returns an array of values which represents the waveform.
                * @param length The length of the waveform to return
                */
            asArray(length: number): Promise<Float32Array>;
    }
    /**
        * Render a segment of the oscillator to an offline context and return the results as an array
        */
    export function generateWaveform(instance: any, length: number): Promise<Float32Array>;
    /**
        * Oscillators with partials
        */
    type SineWithPartials = "sine1" | "sine2" | "sine3" | "sine4" | "sine5" | "sine6" | "sine7" | "sine8" | "sine9" | "sine10" | "sine11" | "sine12" | "sine13" | "sine14" | "sine15" | "sine16" | "sine17" | "sine18" | "sine19" | "sine20" | "sine21" | "sine22" | "sine23" | "sine24" | "sine25" | "sine26" | "sine27" | "sine28" | "sine29" | "sine30" | "sine31" | "sine32";
    type SquareWithPartials = "square1" | "square2" | "square3" | "square4" | "square5" | "square6" | "square7" | "square8" | "square9" | "square10" | "square11" | "square12" | "square13" | "square14" | "square15" | "square16" | "square17" | "square18" | "square19" | "square20" | "square21" | "square22" | "square23" | "square24" | "square25" | "square26" | "square27" | "square28" | "square29" | "square30" | "square31" | "square32";
    type SawtoothWithPartials = "sawtooth1" | "sawtooth2" | "sawtooth3" | "sawtooth4" | "sawtooth5" | "sawtooth6" | "sawtooth7" | "sawtooth8" | "sawtooth9" | "sawtooth10" | "sawtooth11" | "sawtooth12" | "sawtooth13" | "sawtooth14" | "sawtooth15" | "sawtooth16" | "sawtooth17" | "sawtooth18" | "sawtooth19" | "sawtooth20" | "sawtooth21" | "sawtooth22" | "sawtooth23" | "sawtooth24" | "sawtooth25" | "sawtooth26" | "sawtooth27" | "sawtooth28" | "sawtooth29" | "sawtooth30" | "sawtooth31" | "sawtooth32";
    type TriangleWithPartials = "triangle1" | "triangle2" | "triangle3" | "triangle4" | "triangle5" | "triangle6" | "triangle7" | "triangle8" | "triangle9" | "triangle10" | "triangle11" | "triangle12" | "triangle13" | "triangle14" | "triangle15" | "triangle16" | "triangle17" | "triangle18" | "triangle19" | "triangle20" | "triangle21" | "triangle22" | "triangle23" | "triangle24" | "triangle25" | "triangle26" | "triangle27" | "triangle28" | "triangle29" | "triangle30" | "triangle31" | "triangle32";
    type TypeWithPartials = SineWithPartials | SquareWithPartials | TriangleWithPartials | SawtoothWithPartials;
    interface BaseOscillatorOptions extends SourceOptions {
            frequency: Frequency;
            detune: Cents;
            phase: Degrees;
    }
    export type NonCustomOscillatorType = Exclude<OscillatorType, "custom">;
    type AllNonCustomOscillatorType = NonCustomOscillatorType | TypeWithPartials;
    export type ToneOscillatorType = AllNonCustomOscillatorType | "custom";
    export type ExtendedToneOscillatorType = ToneOscillatorType | "pwm" | "pulse";
    /**
        * Oscillator Interfaces
        */
    interface ToneCustomOscillatorOptions extends BaseOscillatorOptions {
            type: "custom";
            partials: number[];
    }
    interface ToneTypeOscillatorOptions extends BaseOscillatorOptions {
            type: NonCustomOscillatorType;
            partialCount?: number;
    }
    interface TonePartialOscillatorOptions extends BaseOscillatorOptions {
            type: TypeWithPartials;
    }
    export type ToneOscillatorConstructorOptions = ToneCustomOscillatorOptions | ToneTypeOscillatorOptions | TonePartialOscillatorOptions;
    export interface ToneOscillatorOptions extends BaseOscillatorOptions {
            type: ToneOscillatorType;
            partialCount: number;
            partials: number[];
    }
    /**
        * FMOscillator Interface
        */
    interface FMBaseOscillatorOptions extends BaseOscillatorOptions {
            harmonicity: Positive;
            modulationIndex: Positive;
            modulationType: AllNonCustomOscillatorType;
    }
    interface FMCustomOscillatorOptions extends FMBaseOscillatorOptions {
            type: "custom";
            partials: number[];
    }
    interface FMTypeOscillatorOptions extends FMBaseOscillatorOptions {
            type: NonCustomOscillatorType;
            partialsCount?: number;
    }
    interface FMPartialsOscillatorOptions extends FMBaseOscillatorOptions {
            type: TypeWithPartials;
    }
    export type FMConstructorOptions = FMTypeOscillatorOptions | FMCustomOscillatorOptions | FMPartialsOscillatorOptions;
    export interface FMOscillatorOptions extends ToneOscillatorOptions {
            harmonicity: Positive;
            modulationIndex: Positive;
            modulationType: AllNonCustomOscillatorType;
    }
    /**
        * AMOscillator Interface
        */
    interface AMBaseOscillatorOptions extends BaseOscillatorOptions {
            harmonicity: Positive;
            modulationType: AllNonCustomOscillatorType;
    }
    interface AMCustomOscillatorOptions extends AMBaseOscillatorOptions {
            type: "custom";
            partials: number[];
    }
    interface AMTypeOscillatorOptions extends AMBaseOscillatorOptions {
            type: NonCustomOscillatorType;
            partialsCount?: number;
    }
    interface AMPartialsOscillatorOptions extends AMBaseOscillatorOptions {
            type: TypeWithPartials;
    }
    export type AMConstructorOptions = AMCustomOscillatorOptions | AMTypeOscillatorOptions | AMPartialsOscillatorOptions;
    export interface AMOscillatorOptions extends ToneOscillatorOptions {
            harmonicity: Positive;
            modulationType: AllNonCustomOscillatorType;
    }
    /**
        * FatOscillator
        */
    interface FatBaseOscillatorOptions extends BaseOscillatorOptions {
            spread: Cents;
            count: Positive;
    }
    interface FatCustomOscillatorOptions extends FatBaseOscillatorOptions {
            type: "custom";
            partials: number[];
    }
    interface FatTypeOscillatorOptions extends FatBaseOscillatorOptions {
            type: NonCustomOscillatorType;
            partialCount?: number;
    }
    interface FatPartialsOscillatorOptions extends FatBaseOscillatorOptions {
            type: TypeWithPartials;
    }
    export type FatConstructorOptions = FatCustomOscillatorOptions | FatTypeOscillatorOptions | FatPartialsOscillatorOptions;
    export interface FatOscillatorOptions extends ToneOscillatorOptions {
            spread: Cents;
            count: Positive;
    }
    /**
        * Pulse Oscillator
        */
    export interface PulseOscillatorOptions extends BaseOscillatorOptions {
            type: "pulse";
            width: AudioRange;
    }
    /**
        * PWM Oscillator
        */
    export interface PWMOscillatorOptions extends BaseOscillatorOptions {
            type: "pwm";
            modulationFrequency: Frequency;
    }
    /**
        * FM Oscillators with partials
        */
    type FMSineWithPartials = "fmsine1" | "fmsine2" | "fmsine3" | "fmsine4" | "fmsine5" | "fmsine6" | "fmsine7" | "fmsine8" | "fmsine9" | "fmsine10" | "fmsine11" | "fmsine12" | "fmsine13" | "fmsine14" | "fmsine15" | "fmsine16" | "fmsine17" | "fmsine18" | "fmsine19" | "fmsine20" | "fmsine21" | "fmsine22" | "fmsine23" | "fmsine24" | "fmsine25" | "fmsine26" | "fmsine27" | "fmsine28" | "fmsine29" | "fmsine30" | "fmsine31" | "fmsine32";
    type FMSquareWithPartials = "fmsquare1" | "fmsquare2" | "fmsquare3" | "fmsquare4" | "fmsquare5" | "fmsquare6" | "fmsquare7" | "fmsquare8" | "fmsquare9" | "fmsquare10" | "fmsquare11" | "fmsquare12" | "fmsquare13" | "fmsquare14" | "fmsquare15" | "fmsquare16" | "fmsquare17" | "fmsquare18" | "fmsquare19" | "fmsquare20" | "fmsquare21" | "fmsquare22" | "fmsquare23" | "fmsquare24" | "fmsquare25" | "fmsquare26" | "fmsquare27" | "fmsquare28" | "fmsquare29" | "fmsquare30" | "fmsquare31" | "fmsquare32";
    type FMSawtoothWithPartials = "fmsawtooth1" | "fmsawtooth2" | "fmsawtooth3" | "fmsawtooth4" | "fmsawtooth5" | "fmsawtooth6" | "fmsawtooth7" | "fmsawtooth8" | "fmsawtooth9" | "fmsawtooth10" | "fmsawtooth11" | "fmsawtooth12" | "fmsawtooth13" | "fmsawtooth14" | "fmsawtooth15" | "fmsawtooth16" | "fmsawtooth17" | "fmsawtooth18" | "fmsawtooth19" | "fmsawtooth20" | "fmsawtooth21" | "fmsawtooth22" | "fmsawtooth23" | "fmsawtooth24" | "fmsawtooth25" | "fmsawtooth26" | "fmsawtooth27" | "fmsawtooth28" | "fmsawtooth29" | "fmsawtooth30" | "fmsawtooth31" | "fmsawtooth32";
    type FMTriangleWithPartials = "fmtriangle1" | "fmtriangle2" | "fmtriangle3" | "fmtriangle4" | "fmtriangle5" | "fmtriangle6" | "fmtriangle7" | "fmtriangle8" | "fmtriangle9" | "fmtriangle10" | "fmtriangle11" | "fmtriangle12" | "fmtriangle13" | "fmtriangle14" | "fmtriangle15" | "fmtriangle16" | "fmtriangle17" | "fmtriangle18" | "fmtriangle19" | "fmtriangle20" | "fmtriangle21" | "fmtriangle22" | "fmtriangle23" | "fmtriangle24" | "fmtriangle25" | "fmtriangle26" | "fmtriangle27" | "fmtriangle28" | "fmtriangle29" | "fmtriangle30" | "fmtriangle31" | "fmtriangle32";
    type FMTypeWithPartials = FMSineWithPartials | FMSquareWithPartials | FMSawtoothWithPartials | FMTriangleWithPartials;
    /**
        * AM Oscillators with partials
        */
    type AMSineWithPartials = "amsine1" | "amsine2" | "amsine3" | "amsine4" | "amsine5" | "amsine6" | "amsine7" | "amsine8" | "amsine9" | "amsine10" | "amsine11" | "amsine12" | "amsine13" | "amsine14" | "amsine15" | "amsine16" | "amsine17" | "amsine18" | "amsine19" | "amsine20" | "amsine21" | "amsine22" | "amsine23" | "amsine24" | "amsine25" | "amsine26" | "amsine27" | "amsine28" | "amsine29" | "amsine30" | "amsine31" | "amsine32";
    type AMSquareWithPartials = "amsquare1" | "amsquare2" | "amsquare3" | "amsquare4" | "amsquare5" | "amsquare6" | "amsquare7" | "amsquare8" | "amsquare9" | "amsquare10" | "amsquare11" | "amsquare12" | "amsquare13" | "amsquare14" | "amsquare15" | "amsquare16" | "amsquare17" | "amsquare18" | "amsquare19" | "amsquare20" | "amsquare21" | "amsquare22" | "amsquare23" | "amsquare24" | "amsquare25" | "amsquare26" | "amsquare27" | "amsquare28" | "amsquare29" | "amsquare30" | "amsquare31" | "amsquare32";
    type AMSawtoothWithPartials = "amsawtooth1" | "amsawtooth2" | "amsawtooth3" | "amsawtooth4" | "amsawtooth5" | "amsawtooth6" | "amsawtooth7" | "amsawtooth8" | "amsawtooth9" | "amsawtooth10" | "amsawtooth11" | "amsawtooth12" | "amsawtooth13" | "amsawtooth14" | "amsawtooth15" | "amsawtooth16" | "amsawtooth17" | "amsawtooth18" | "amsawtooth19" | "amsawtooth20" | "amsawtooth21" | "amsawtooth22" | "amsawtooth23" | "amsawtooth24" | "amsawtooth25" | "amsawtooth26" | "amsawtooth27" | "amsawtooth28" | "amsawtooth29" | "amsawtooth30" | "amsawtooth31" | "amsawtooth32";
    type AMTriangleWithPartials = "amtriangle1" | "amtriangle2" | "amtriangle3" | "amtriangle4" | "amtriangle5" | "amtriangle6" | "amtriangle7" | "amtriangle8" | "amtriangle9" | "amtriangle10" | "amtriangle11" | "amtriangle12" | "amtriangle13" | "amtriangle14" | "amtriangle15" | "amtriangle16" | "amtriangle17" | "amtriangle18" | "amtriangle19" | "amtriangle20" | "amtriangle21" | "amtriangle22" | "amtriangle23" | "amtriangle24" | "amtriangle25" | "amtriangle26" | "amtriangle27" | "amtriangle28" | "amtriangle29" | "amtriangle30" | "amtriangle31" | "amtriangle32";
    type AMTypeWithPartials = AMSineWithPartials | AMSquareWithPartials | AMSawtoothWithPartials | AMTriangleWithPartials;
    /**
        * Fat Oscillators with partials
        */
    type FatSineWithPartials = "fatsine1" | "fatsine2" | "fatsine3" | "fatsine4" | "fatsine5" | "fatsine6" | "fatsine7" | "fatsine8" | "fatsine9" | "fatsine10" | "fatsine11" | "fatsine12" | "fatsine13" | "fatsine14" | "fatsine15" | "fatsine16" | "fatsine17" | "fatsine18" | "fatsine19" | "fatsine20" | "fatsine21" | "fatsine22" | "fatsine23" | "fatsine24" | "fatsine25" | "fatsine26" | "fatsine27" | "fatsine28" | "fatsine29" | "fatsine30" | "fatsine31" | "fatsine32";
    type FatSquareWithPartials = "fatsquare1" | "fatsquare2" | "fatsquare3" | "fatsquare4" | "fatsquare5" | "fatsquare6" | "fatsquare7" | "fatsquare8" | "fatsquare9" | "fatsquare10" | "fatsquare11" | "fatsquare12" | "fatsquare13" | "fatsquare14" | "fatsquare15" | "fatsquare16" | "fatsquare17" | "fatsquare18" | "fatsquare19" | "fatsquare20" | "fatsquare21" | "fatsquare22" | "fatsquare23" | "fatsquare24" | "fatsquare25" | "fatsquare26" | "fatsquare27" | "fatsquare28" | "fatsquare29" | "fatsquare30" | "fatsquare31" | "fatsquare32";
    type FatSawtoothWithPartials = "fatsawtooth1" | "fatsawtooth2" | "fatsawtooth3" | "fatsawtooth4" | "fatsawtooth5" | "fatsawtooth6" | "fatsawtooth7" | "fatsawtooth8" | "fatsawtooth9" | "fatsawtooth10" | "fatsawtooth11" | "fatsawtooth12" | "fatsawtooth13" | "fatsawtooth14" | "fatsawtooth15" | "fatsawtooth16" | "fatsawtooth17" | "fatsawtooth18" | "fatsawtooth19" | "fatsawtooth20" | "fatsawtooth21" | "fatsawtooth22" | "fatsawtooth23" | "fatsawtooth24" | "fatsawtooth25" | "fatsawtooth26" | "fatsawtooth27" | "fatsawtooth28" | "fatsawtooth29" | "fatsawtooth30" | "fatsawtooth31" | "fatsawtooth32";
    type FatTriangleWithPartials = "fattriangle1" | "fattriangle2" | "fattriangle3" | "fattriangle4" | "fattriangle5" | "fattriangle6" | "fattriangle7" | "fattriangle8" | "fattriangle9" | "fattriangle10" | "fattriangle11" | "fattriangle12" | "fattriangle13" | "fattriangle14" | "fattriangle15" | "fattriangle16" | "fattriangle17" | "fattriangle18" | "fattriangle19" | "fattriangle20" | "fattriangle21" | "fattriangle22" | "fattriangle23" | "fattriangle24" | "fattriangle25" | "fattriangle26" | "fattriangle27" | "fattriangle28" | "fattriangle29" | "fattriangle30" | "fattriangle31" | "fattriangle32";
    type FatTypeWithPartials = FatSineWithPartials | FatSquareWithPartials | FatSawtoothWithPartials | FatTriangleWithPartials;
    /**
        * Omni FM
        */
    interface OmniFMCustomOscillatorOptions extends FMBaseOscillatorOptions {
            type: "fmcustom";
            partials: number[];
    }
    interface OmniFMTypeOscillatorOptions extends FMBaseOscillatorOptions {
            type: "fmsine" | "fmsquare" | "fmsawtooth" | "fmtriangle";
            partialsCount?: number;
    }
    interface OmniFMPartialsOscillatorOptions extends FMBaseOscillatorOptions {
            type: FMTypeWithPartials;
    }
    /**
        * Omni AM
        */
    interface OmniAMCustomOscillatorOptions extends AMBaseOscillatorOptions {
            type: "amcustom";
            partials: number[];
    }
    interface OmniAMTypeOscillatorOptions extends AMBaseOscillatorOptions {
            type: "amsine" | "amsquare" | "amsawtooth" | "amtriangle";
            partialsCount?: number;
    }
    interface OmniAMPartialsOscillatorOptions extends AMBaseOscillatorOptions {
            type: AMTypeWithPartials;
    }
    /**
        * Omni Fat
        */
    interface OmniFatCustomOscillatorOptions extends FatBaseOscillatorOptions {
            type: "fatcustom";
            partials: number[];
    }
    interface OmniFatTypeOscillatorOptions extends FatBaseOscillatorOptions {
            type: "fatsine" | "fatsquare" | "fatsawtooth" | "fattriangle";
            partialsCount?: number;
    }
    interface OmniFatPartialsOscillatorOptions extends FatBaseOscillatorOptions {
            type: FatTypeWithPartials;
    }
    export type OmniOscillatorType = "fatsine" | "fatsquare" | "fatsawtooth" | "fattriangle" | "fatcustom" | FatTypeWithPartials | "fmsine" | "fmsquare" | "fmsawtooth" | "fmtriangle" | "fmcustom" | FMTypeWithPartials | "amsine" | "amsquare" | "amsawtooth" | "amtriangle" | "amcustom" | AMTypeWithPartials | TypeWithPartials | OscillatorType | "pulse" | "pwm";
    export type OmniOscillatorConstructorOptions = PulseOscillatorOptions | PWMOscillatorOptions | OmniFatCustomOscillatorOptions | OmniFatTypeOscillatorOptions | OmniFatPartialsOscillatorOptions | OmniFMCustomOscillatorOptions | OmniFMTypeOscillatorOptions | OmniFMPartialsOscillatorOptions | OmniAMCustomOscillatorOptions | OmniAMTypeOscillatorOptions | OmniAMPartialsOscillatorOptions | ToneOscillatorConstructorOptions;
    export type OmniOscillatorOptions = PulseOscillatorOptions & PWMOscillatorOptions & OmniFatCustomOscillatorOptions & OmniFatTypeOscillatorOptions & OmniFatPartialsOscillatorOptions & OmniFMCustomOscillatorOptions & OmniFMTypeOscillatorOptions & OmniFMPartialsOscillatorOptions & OmniAMCustomOscillatorOptions & OmniAMTypeOscillatorOptions & OmniAMPartialsOscillatorOptions & ToneOscillatorConstructorOptions;
    type OmitSourceOptions<T extends BaseOscillatorOptions> = Omit<T, "frequency" | "detune" | "context">;
    /**
        * The settable options for the omni oscillator inside of the source which excludes certain attributes that are defined by the parent class
        */
    export type OmniOscillatorSynthOptions = OmitSourceOptions<PulseOscillatorOptions> | OmitSourceOptions<PWMOscillatorOptions> | OmitSourceOptions<OmniFatCustomOscillatorOptions> | OmitSourceOptions<OmniFatTypeOscillatorOptions> | OmitSourceOptions<OmniFatPartialsOscillatorOptions> | OmitSourceOptions<OmniFMCustomOscillatorOptions> | OmitSourceOptions<OmniFMTypeOscillatorOptions> | OmitSourceOptions<OmniFMPartialsOscillatorOptions> | OmitSourceOptions<OmniAMCustomOscillatorOptions> | OmitSourceOptions<OmniAMTypeOscillatorOptions> | OmitSourceOptions<OmniAMPartialsOscillatorOptions> | OmitSourceOptions<ToneOscillatorConstructorOptions>;
    export {};
}

declare module 'tone/source/OneShotSource' {
    import { Gain } from "tone/core/context/Gain";
    import { ToneAudioNode, ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    import { GainFactor, Seconds, Time } from "tone/core/type/Units";
    import { BasicPlaybackState } from "tone/core/util/StateTimeline";
    export type OneShotSourceCurve = "linear" | "exponential";
    type onEndedCallback = (source: OneShotSource<any>) => void;
    export interface OneShotSourceOptions extends ToneAudioNodeOptions {
            onended: onEndedCallback;
            fadeIn: Time;
            fadeOut: Time;
            curve: OneShotSourceCurve;
    }
    /**
        * Base class for fire-and-forget nodes
        */
    export abstract class OneShotSource<Options extends ToneAudioNodeOptions> extends ToneAudioNode<Options> {
            /**
                * The callback to invoke after the
                * source is done playing.
                */
            onended: onEndedCallback;
            /**
                * Sources do not have input nodes
                */
            input: undefined;
            /**
                * The start time
                */
            protected _startTime: number;
            /**
                * The stop time
                */
            protected _stopTime: number;
            /**
                * The public output node
                */
            output: Gain;
            /**
                * The output gain node.
                */
            protected _gainNode: Gain<number>;
            /**
                * The fadeIn time of the amplitude envelope.
                */
            protected _fadeIn: Time;
            /**
                * The fadeOut time of the amplitude envelope.
                */
            protected _fadeOut: Time;
            /**
                * The curve applied to the fades, either "linear" or "exponential"
                */
            protected _curve: OneShotSourceCurve;
            constructor(options: OneShotSourceOptions);
            static getDefaults(): OneShotSourceOptions;
            /**
                * Stop the source node
                */
            protected abstract _stopSource(time: Seconds): void;
            /**
                * Start the source node at the given time
                * @param  time When to start the node
                */
            protected abstract start(time?: Time): this;
            /**
                * Start the source at the given time
                * @param  time When to start the source
                */
            protected _startGain(time: Seconds, gain?: GainFactor): this;
            /**
                * Stop the source node at the given time.
                * @param time When to stop the source
                */
            stop(time?: Time): this;
            /**
                * Stop the source at the given time
                * @param  time When to stop the source
                */
            protected _stopGain(time: Seconds): this;
            /**
                * Invoke the onended callback
                */
            protected _onended(): void;
            /**
                * Get the playback state at the given time
                */
            getStateAtTime: (time: Time) => BasicPlaybackState;
            /**
                * Get the playback state at the current time
                */
            readonly state: BasicPlaybackState;
            /**
                * Cancel a scheduled stop event
                */
            cancelStop(): this;
            dispose(): this;
    }
    export {};
}

declare module 'tone/signal/SignalOperator' {
    import { InputNode, ToneAudioNode, ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    /**
      * A signal operator has an input and output and modifies the signal.
      */
    export abstract class SignalOperator<Options extends ToneAudioNodeOptions> extends ToneAudioNode<Options> {
        constructor(options?: Partial<Options>);
        connect(destination: InputNode, outputNum?: number, inputNum?: number): this;
    }
}

declare module 'tone/signal/ToneConstantSource' {
    import { Param } from "tone/core/context/Param";
    import { Seconds, Time, Unit, UnitName } from "tone/core/type/Units";
    import { OneShotSource, OneShotSourceOptions } from "tone/source/OneShotSource";
    export interface ToneConstantSourceOptions<Type> extends OneShotSourceOptions {
            convert: boolean;
            offset: Type;
            units: UnitName;
    }
    /**
        * Wrapper around the native fire-and-forget ConstantSource.
        * Adds the ability to reschedule the stop method.
        * @category Signal
        */
    export class ToneConstantSource<Type extends Unit = number> extends OneShotSource<ToneConstantSourceOptions<Type>> {
            readonly name: string;
            /**
                * The offset of the signal generator
                */
            readonly offset: Param<Type>;
            /**
                * @param  offset   The offset value
                */
            constructor(offset: Type);
            constructor(options?: Partial<ToneConstantSourceOptions<Type>>);
            static getDefaults(): ToneConstantSourceOptions<any>;
            /**
                * Start the source node at the given time
                * @param  time When to start the source
                */
            start(time?: Time): this;
            protected _stopSource(time?: Seconds): void;
            dispose(): this;
    }
}

declare module 'tone/instrument/Monophonic' {
    import { Envelope } from "tone/component/envelope/Envelope";
    import { FrequencyClass } from "tone/core/type/Frequency";
    import { Cents, Frequency, NormalRange, Seconds, Time } from "tone/core/type/Units";
    import { Instrument, InstrumentOptions } from "tone/instrument/Instrument";
    import { Signal } from "tone/signal/Signal";
    type onSilenceCallback = (instrument: Monophonic<any>) => void;
    export interface MonophonicOptions extends InstrumentOptions {
            portamento: Seconds;
            onsilence: onSilenceCallback;
            detune: Cents;
    }
    /**
        * Abstract base class for other monophonic instruments to extend.
        */
    export abstract class Monophonic<Options extends MonophonicOptions> extends Instrument<Options> {
            /**
                * The glide time between notes.
                */
            portamento: Seconds;
            /**
                * Invoked when the release has finished and the output is silent.
                */
            onsilence: onSilenceCallback;
            /**
                * The instrument's envelope
                */
            abstract envelope: Envelope;
            /**
                * The instrument's frequency signal.
                */
            abstract readonly frequency: Signal<Frequency>;
            /**
                * The instrument's detune control signal.
                */
            abstract readonly detune: Signal<Cents>;
            constructor(options?: Partial<MonophonicOptions>);
            static getDefaults(): MonophonicOptions;
            /**
                * Trigger the attack of the note optionally with a given velocity.
                * @param  note The note to trigger.
                * @param  time When the note should start.
                * @param  velocity The velocity scaler determines how "loud" the note will be triggered.
                * @example
                * synth.triggerAttack("C4");
                * @example
                * //trigger the note a half second from now at half velocity
                * synth.triggerAttack("C4", "+0.5", 0.5);
                */
            triggerAttack(note: Frequency | FrequencyClass, time?: Time, velocity?: NormalRange): this;
            /**
                * Trigger the release portion of the envelope
                * @param  time If no time is given, the release happens immediatly
                * @example
                * synth.triggerRelease();
                */
            triggerRelease(time?: Time): this;
            /**
                * Internal method which starts the envelope attack
                */
            protected abstract _triggerEnvelopeAttack(time: Seconds, velocity: NormalRange): void;
            /**
                * Internal method which starts the envelope release
                */
            protected abstract _triggerEnvelopeRelease(time: Seconds): void;
            /**
                * Get the level of the output at the given time. Measures
                * the envelope(s) value at the time.
                * @param time The time to query the envelope value
                * @return The output level between 0-1
                */
            getLevelAtTime(time: Time): NormalRange;
            /**
                * Set the note at the given time. If no time is given, the note
                * will set immediately.
                * @param note The note to change to.
                * @param  time The time when the note should be set.
                * @example
                * //change to F#6 in one quarter note from now.
                * synth.setNote("F#6", "+4n");
                * @example
                * //change to Bb4 right now
                * synth.setNote("Bb4");
                */
            setNote(note: Frequency | FrequencyClass, time?: Time): this;
    }
    export {};
}

declare module 'tone/instrument/Instrument' {
    import { Param } from "tone/core/context/Param";
    import { OutputNode, ToneAudioNode, ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    import { Decibels, Frequency, NormalRange, Time } from "tone/core/type/Units";
    export interface InstrumentOptions extends ToneAudioNodeOptions {
            volume: Decibels;
    }
    /**
        * Base-class for all instruments
        */
    export abstract class Instrument<Options extends InstrumentOptions> extends ToneAudioNode<Options> {
            output: OutputNode;
            /**
                * The instrument only has an output
                */
            input: undefined;
            /**
                * The volume of the output in decibels.
                * @example
                * source.volume.value = -6;
                */
            volume: Param<Decibels>;
            constructor(options?: Partial<InstrumentOptions>);
            static getDefaults(): InstrumentOptions;
            /**
                * Sync the instrument to the Transport. All subsequent calls of
                * [[triggerAttack]] and [[triggerRelease]]
                * will be scheduled along the transport.
                * @example
                * instrument.sync()
                * //schedule 3 notes when the transport first starts
                * instrument.triggerAttackRelease('C4', '8n', 0)
                * instrument.triggerAttackRelease('E4', '8n', '8n')
                * instrument.triggerAttackRelease('G4', '8n', '4n')
                * //start the transport to hear the notes
                * Transport.start()
                * @returns {Instrument} this
                */
            sync(): this;
            /**
                * Wrap the given method so that it can be synchronized
                * @param method Which method to wrap and sync
                * @param  timePosition What position the time argument appears in
                */
            protected _syncMethod(method: string, timePosition: number): void;
            /**
                * Unsync the instrument from the Transport
                */
            unsync(): this;
            /**
                * Trigger the attack and then the release after the duration.
                * @param  note     The note to trigger.
                * @param  duration How long the note should be held for before
                *                         triggering the release. This value must be greater than 0.
                * @param time  When the note should be triggered.
                * @param  velocity The velocity the note should be triggered at.
                * @example
                * //trigger "C4" for the duration of an 8th note
                * synth.triggerAttackRelease("C4", "8n");
                */
            triggerAttackRelease(note: Frequency, duration: Time, time?: Time, velocity?: NormalRange): this;
            /**
                * Start the instrument's note.
                * @param note the note to trigger
                * @param time the time to trigger the ntoe
                * @param velocity the velocity to trigger the note (betwee 0-1)
                */
            abstract triggerAttack(note: Frequency, time?: Time, velocity?: NormalRange): this;
            /**
                * Trigger the release phase of the current note.
                * @param time when to trigger the release
                */
            abstract triggerRelease(...args: any[]): this;
            /**
                * clean up
                * @returns {Instrument} this
                */
            dispose(): this;
    }
}

declare module 'tone/effect/FeedbackEffect' {
    import { Param } from "tone/core/context/Param";
    import { NormalRange } from "tone/core/type/Units";
    import { Effect, EffectOptions } from "tone/effect/Effect";
    export interface FeedbackEffectOptions extends EffectOptions {
            /**
                * The feedback from the output back to the input
                * ```
                * +---<--------<---+
                * |                |
                * |  +----------+  |
                * +--> feedback +>-+
                *    +----------+
                * ```
                */
            feedback: NormalRange;
    }
    /**
        * FeedbackEffect provides a loop between an audio source and its own output.
        * This is a base-class for feedback effects.
        */
    export abstract class FeedbackEffect<Options extends FeedbackEffectOptions> extends Effect<Options> {
            readonly name: string;
            /**
                * The amount of signal which is fed back into the effect input.
                */
            feedback: Param<NormalRange>;
            constructor(options: FeedbackEffectOptions);
            static getDefaults(): FeedbackEffectOptions;
            dispose(): this;
    }
}

declare module 'tone/effect/Effect' {
    import { CrossFade } from "tone/component/channel/CrossFade";
    import { Gain } from "tone/core/context/Gain";
    import { ToneAudioNode, ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    import { NormalRange } from "tone/core/type/Units";
    import { Signal } from "tone/signal/Signal";
    export interface EffectOptions extends ToneAudioNodeOptions {
            wet: NormalRange;
    }
    /**
        * Effect is the base class for effects. Connect the effect between
        * the effectSend and effectReturn GainNodes, then control the amount of
        * effect which goes to the output using the wet control.
        */
    export abstract class Effect<Options extends EffectOptions> extends ToneAudioNode<Options> {
            readonly name: string;
            /**
                * The wet control is how much of the effected
                * will pass through to the output. 1 = 100% effected
                * signal, 0 = 100% dry signal.
                */
            wet: Signal<NormalRange>;
            /**
                * connect the effectSend to the input of hte effect
                */
            protected effectSend: Gain;
            /**
                * connect the output of the effect to the effectReturn
                */
            protected effectReturn: Gain;
            /**
                * The effect input node
                */
            input: Gain;
            /**
                * The effect output
                */
            output: CrossFade;
            constructor(options: EffectOptions);
            static getDefaults(): EffectOptions;
            /**
                * chains the effect in between the effectSend and effectReturn
                */
            protected connectEffect(effect: ToneAudioNode | AudioNode): this;
            dispose(): this;
    }
}

declare module 'tone/component/analysis/MeterBase' {
    import { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    import { Analyser } from "tone/component/analysis/Analyser";
    export type MeterBaseOptions = ToneAudioNodeOptions;
    /**
        * The base class for Metering classes.
        */
    export class MeterBase<Options extends MeterBaseOptions> extends ToneAudioNode<Options> {
            readonly name: string;
            /**
                * The signal to be analysed
                */
            input: InputNode;
            /**
                * The output is just a pass through of the input
                */
            output: OutputNode;
            /**
                * The analyser node for the incoming signal
                */
            protected _analyser: Analyser;
            constructor(options?: Partial<MeterBaseOptions>);
            dispose(): this;
    }
}

declare module 'tone/core/context/ToneAudioWorklet' {
    import { ToneAudioNode, ToneAudioNodeOptions } from "tone/core/context/ToneAudioNode";
    export type ToneAudioWorkletOptions = ToneAudioNodeOptions;
    export abstract class ToneAudioWorklet<Options extends ToneAudioWorkletOptions> extends ToneAudioNode<Options> {
            readonly name: string;
            /**
                * The processing node
                */
            protected _worklet: AudioWorkletNode;
            /**
                * The constructor options for the node
                */
            protected workletOptions: Partial<AudioWorkletNodeOptions>;
            /**
                * The code which is run in the worklet
                */
            protected abstract _audioWorklet(): string;
            /**
                * Get the name of the audio worklet
                */
            protected abstract _audioWorkletName(): string;
            /**
                * Invoked when the module is loaded and the node is created
                */
            protected abstract onReady(node: AudioWorkletNode): void;
            constructor(options: Options);
            dispose(): this;
    }
}

